/**
 * useSemanticTags - Custom hook for managing semantic tags/keywords
 * 
 * This hook manages topic/keyword tags for text documents:
 * - User-added tags (manually entered keywords)
 * - API-generated tags (automatic suggestions via classification API)
 * - Workspace hydration (loading saved tags when switching workspaces)
 * 
 * ARCHITECTURE:
 * 
 * Tags come from two sources:
 * 1. "user" - manually added by the user via TagInput
 * 2. "api" - automatically suggested by the classification API
 * 
 * Both are stored separately but merged for display. This allows:
 * - Preserving user tags when re-running classification
 * - Distinguishing between manual and automatic tags
 * - Easy filtering/clearing of API-generated tags
 */
import { useCallback, useMemo, useRef, useState, useEffect } from "react";
import type { TagItem } from "../../types/Tag";
import type { ThesaurusIndexItem } from "../../types/Thesaurus";
import { loadThesaurusIndex, findInThesaurus } from "../../shared/utils/thesaurusHelpers";
import { useErrorLogger } from "./useErrorLogger";

type Options = {
  initialTags?: TagItem[];
  /** Changes when a different workspace is selected; triggers hydration */
  hydrateKey?: string | null;
  /** Optional segment ID - when provided, tags are filtered/scoped to this segment */
  segmentId?: string | null;
};

export function useSemanticTags(opts?: Options) {
  // Tags are stored separately by source
  // User tags: manually added by the user
  const [userTags, setUserTags] = useState<TagItem[]>([]);
  // API tags: generated by the classification API
  const [apiTags, setApiTags] = useState<TagItem[]>([]);
  
  // Input field state for custom tag entry
  const [customTagInput, setCustomTagInput] = useState("");

  // Ref to the tag table scroll container (for scrolling to top after classification)
  const tagTableRef = useRef<HTMLDivElement>(null);
  const logError = useErrorLogger({ hook: "useSemanticTags" });

  /**
   * ============================================================================
   * WORKSPACE HYDRATION: Load saved tags when switching workspaces
   * ============================================================================
   * 
   * This effect runs when hydrateKey changes (typically the workspace ID).
   * It loads the saved tags from the workspace and separates them by source.
   * 
   * BUG FIX: Only trigger hydration when workspace ID changes, not when tags update.
   * If we include initialTags in dependencies, we create a circular loop:
   * 1. runClassify updates apiTags -> combinedTags changes
   * 2. WorkspaceContainer saves tags -> workspace.tags changes -> initialTags changes
   * 3. Hydration effect runs -> resets apiTags/userTags -> combinedTags changes
   * 4. Loop continues infinitely
   * 
   * Solution: Only depend on hydrateKey (workspace ID). Read initialTags inside
   * the effect but don't include it in dependencies. Use a ref to track last
   * hydrated workspace to prevent unnecessary re-hydrations.
   */
  const lastHydratedWorkspaceRef = useRef<string | null>(null);

  useEffect(() => {
    // Reset ref when no workspace is selected (allows re-hydration when workspace is selected again)
    if (!opts?.hydrateKey) {
      lastHydratedWorkspaceRef.current = null;
      // Clear tags when no workspace is selected
      setUserTags([]);
      setApiTags([]);
      return;
    }
    
    // Only hydrate when workspace ID changes, not when tags in workspace update
    if (lastHydratedWorkspaceRef.current === opts.hydrateKey) {
      return;
    }
    
    // Mark this workspace as hydrated
    lastHydratedWorkspaceRef.current = opts.hydrateKey;
    
    // Always read the current value of initialTags (not from closure)
    // This ensures we get the tags for the NEW workspace, not the old one
    // Handle undefined/null/empty explicitly for new workspaces that don't have tags initialized
    // If initialTags is undefined, null, or not an array, treat as empty (no tags)
    const tags = Array.isArray(opts?.initialTags) ? opts.initialTags : [];
    const u = tags.filter((t) => t.source === "user");
    const a = tags.filter((t) => t.source === "api");
    
    // ALWAYS reset tags when workspace changes (even if empty arrays)
    // This clears previous workspace tags and loads new workspace tags
    // Empty arrays ensure empty workspaces don't inherit tags from previous workspace
    setUserTags(u);
    setApiTags(a);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    opts?.hydrateKey // Only depend on workspace ID, not on initialTags (prevents infinite loop when tags update)
  ]);

  /**
   * ============================================================================
   * DERIVED STATE: Merge tags from both sources
   * ============================================================================
   * 
   * Combines user tags and API tags into a single array, removing duplicates.
   * A tag is considered duplicate if it has the same name (case-insensitive)
   * from the same source.
   * 
   * Filters tags by segmentId when segmentId is provided:
   * - If segmentId is provided, shows only tags for that segment (or tags without segmentId)
   * - If segmentId is null/undefined, shows only document-level tags (no segmentId)
   */
  const combinedTags: TagItem[] = useMemo(() => {
    const key = (t: TagItem) => `${t.source}:${t.name.toLowerCase()}:${t.label || ''}:${t.parentId || ''}`;
    const map = new Map<string, TagItem>();
    
    // Filter tags based on segmentId context
    let tagsToProcess: TagItem[] = [];
    if (opts?.segmentId) {
      // Segment view: show ONLY tags for this specific segment
      tagsToProcess = [...userTags, ...apiTags].filter(t => 
        t.segmentId === opts.segmentId
      );
    } else {
      // Document view: show only document-level tags (no segmentId)
      tagsToProcess = [...userTags, ...apiTags].filter(t => !t.segmentId);
    }
    
    // User tags appear first in the array
    tagsToProcess.forEach((t) => map.set(key(t), t));
    return Array.from(map.values());
  }, [userTags, apiTags, opts?.segmentId]);

  /**
   * ============================================================================
   * TAG ACTIONS: Add, delete, replace
   * ============================================================================
   */

  /**
   * Add a custom user tag
   * Prevents duplicates (case-insensitive) and empty tags
   * Also looks up KeywordID and ParentID from thesaurus if available
   * Automatically restructures tags to create hierarchical relationships
   * Associates tag with current segment if segmentId is provided
   */
  const addCustomTag = useCallback(
    async (name: string, keywordId?: number, parentId?: number, segmentId?: string | null) => {
      const tag = name.trim();
      if (!tag) return;
      
      // Check if this exact tag already exists (name + keywordId + parentId)
      // Allow same name in different hierarchies (different parentId)
      const exists = combinedTags.some((t) => {
        const nameMatch = t.name.toLowerCase() === tag.toLowerCase();
        
        // If neither has IDs, just check name (custom tags without thesaurus)
        if (!t.label && !keywordId) return nameMatch;
        
        // If both have IDs, check name + keywordId + parentId
        if (t.label && keywordId) {
          return nameMatch && t.label === keywordId && t.parentId === parentId;
        }
        
        // One has ID, one doesn't - treat as different tags
        return false;
      });
      
      if (exists) return;
      
      // Use provided keywordId/parentId or try to find them from thesaurus
      let finalKeywordId: number | undefined = keywordId;
      let finalParentId: number | undefined = parentId;
      let thesaurusIndex: ThesaurusIndexItem[] | undefined;
      
      if (!finalKeywordId) {
        // No keywordId provided, look up in thesaurus by name
        try {
          thesaurusIndex = await loadThesaurusIndex();
          const entry = findInThesaurus({ name: tag }, thesaurusIndex);
          finalKeywordId = entry?.id;
          finalParentId = entry?.parentId;
        } catch {
          // Thesaurus not available, that's fine
          finalKeywordId = undefined;
          finalParentId = undefined;
        }
      } else if (!finalParentId) {
        // KeywordId provided but no parentId, look up parentId
        try {
          thesaurusIndex = await loadThesaurusIndex();
          const entry = findInThesaurus({ name: tag, keywordId: finalKeywordId }, thesaurusIndex);
          finalParentId = entry?.parentId;
        } catch {
          // Thesaurus not available, that's fine
          finalParentId = undefined;
        }
      }
      
      // Add the new tag to user tags
      const newTag = { 
        name: tag, 
        source: "user" as const,
        label: finalKeywordId,    // Include KeywordID if found
        parentId: finalParentId,  // Include ParentID if found (disambiguates duplicates)
        segmentId: segmentId ?? undefined, // Associate with segment if provided
      };
      
      // Simply add the new tag - let the TagTable handle hierarchy building
      setUserTags((prev) => [newTag, ...prev]);
    },
    [combinedTags]
  );

  /**
   * Delete a tag by name and context (keywordId + parentId)
   * Removes the specific tag instance from both user and API tags
   */
  const deleteTag = useCallback((name: string, keywordId?: number, parentId?: number) => {
    // Filter out the specific tag instance based on name + keywordId + parentId
    setUserTags((prev) => prev.filter((t) => {
      const nameMatch = t.name === name;
      if (!nameMatch) return true;
      
      // If no IDs provided, match by name only (backward compatibility)
      if (keywordId === undefined && parentId === undefined) return false;
      
      // Match by name + keywordId + parentId
      return !(t.label === keywordId && t.parentId === parentId);
    }));
    
    setApiTags((prev) => prev.filter((t) => {
      const nameMatch = t.name === name;
      if (!nameMatch) return true;
      
      // If no IDs provided, match by name only (backward compatibility)
      if (keywordId === undefined && parentId === undefined) return false;
      
      // Match by name + keywordId + parentId
      return !(t.label === keywordId && t.parentId === parentId);
    }));
  }, []);

  /**
   * Replace all tags (used when loading from workspace)
   * Separates by source and updates both states
   */
  const replaceAllTags = useCallback((tags: TagItem[]) => {
    const u = tags.filter((t) => t.source === "user");
    const a = tags.filter((t) => t.source === "api");
    setUserTags(u);
    setApiTags(a);
  }, []);

  /**
   * ============================================================================
   * CLASSIFICATION API: Automatic tag generation
   * ============================================================================
   */

  /**
   * Call the classification API to generate tag suggestions
   * Replaces all API tags with new results (preserves user tags)
   * For duplicate KeywordIDs, adds ALL instances from thesaurus
   * Scrolls the tag panel to top after completion
   * Associates tags with segment if segmentId is provided
   */
  const runClassify = useCallback(async (text: string, segmentId?: string | null) => {
    if (!text.trim()) return;

    let data: { results?: unknown };
    try {
      const { classify: apiClassify } = await import("../../shared/utils/api");
      data = await apiClassify(text);
    } catch (error) {
      const appError = logError(error, {
        operation: "classify text",
        payloadLength: text.length,
      });
      throw appError;
    }
    
    // Transform API response into TagItem array
    // API returns 'label' field which is the KeywordID from thesaurus
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const apiResults: any[] = Array.isArray(data?.result)
      ? (data?.result as any[])
      : Array.isArray(data?.results)
      ? (data?.results as any[])
      : [];
    
    // Expand duplicate KeywordIDs into multiple tags
    const newTags: TagItem[] = [];
    
    for (const r of apiResults) {
      const keywordId = r.label;
      const name = r.name;
      
      // Check if user already has this tag (by name)
      const userAlreadyHas = userTags.some(t => t.name.toLowerCase() === name.toLowerCase());
      if (userAlreadyHas) {
        // Skip this tag - user version takes precedence
        continue;
      }
      
      if (keywordId) {
        // Try to find all instances of this KeywordID in the thesaurus
        try {
          const thesaurusIndex = await loadThesaurusIndex();
          const matches = thesaurusIndex.filter(item => item.id === keywordId);
          
          if (matches.length > 1) {
            // Multiple instances found - add all of them (if not already added by user)
            for (const match of matches) {
              const matchName = match.label.toLowerCase();
              const userHasThisInstance = userTags.some(t => 
                t.name.toLowerCase() === matchName && 
                t.label === match.id && 
                t.parentId === match.parentId
              );
              
              if (!userHasThisInstance) {
                newTags.push({
                  name: match.label, // Use thesaurus label (might be different from API name)
                  source: "api" as const,
                  label: match.id,
                  parentId: match.parentId,
                  segmentId: segmentId ?? undefined, // Associate with segment if provided
                });
              }
            }
          } else if (matches.length === 1) {
            // Single instance - check if user already has this exact instance
            const match = matches[0];
            const userHasThisInstance = userTags.some(t => 
              t.name.toLowerCase() === match.label.toLowerCase() && 
              t.label === match.id && 
              t.parentId === match.parentId
            );
            
            if (!userHasThisInstance) {
              newTags.push({
                name: match.label,
                source: "api" as const,
                label: match.id,
                parentId: match.parentId,
                segmentId: segmentId ?? undefined, // Associate with segment if provided
              });
            }
          } else {
            // No thesaurus match - add as-is (fallback) if user doesn't have it
            newTags.push({
              name: name,
              source: "api" as const,
              label: keywordId,
              segmentId: segmentId ?? undefined, // Associate with segment if provided
            });
          }
        } catch {
          // Thesaurus not available - add as-is (fallback) if user doesn't have it
          newTags.push({
            name: name,
            source: "api" as const,
            label: keywordId,
            segmentId: segmentId ?? undefined, // Associate with segment if provided
          });
        }
      } else {
        // No KeywordID - add as-is if user doesn't have it
        newTags.push({
          name: name,
          source: "api" as const,
          segmentId: segmentId ?? undefined, // Associate with segment if provided
        });
      }
    }
    
    // Replace API tags (user tags remain unchanged)
    // If segmentId is provided, only replace tags for that segment
    // Otherwise, replace all API tags (document-level classification)
    if (segmentId) {
      // Segment-specific: remove old tags for this segment, add new ones
      setApiTags((prev) => {
        // Keep tags from other segments and document-level tags
        const otherTags = prev.filter(t => !t.segmentId || t.segmentId !== segmentId);
        // Add new tags for this segment
        return [...otherTags, ...newTags];
      });
    } else {
      // Document-level: replace all API tags (preserve user tags)
      setApiTags(newTags);
    }
    
    // Scroll tag panel to top to show new results
    setTimeout(
      () => tagTableRef.current?.scrollTo({ top: 0, behavior: "smooth" }),
      100
    );
  }, [userTags]);

  /**
   * ============================================================================
   * ALL TAGS: Get all tags regardless of segmentId filter
   * ============================================================================
   * 
   * This is used for saving - we need to save ALL tags, not just the filtered
   * combinedTags which only shows tags for the current segment view.
   */
  const allTags: TagItem[] = useMemo(() => {
    const key = (t: TagItem) => `${t.source}:${t.name.toLowerCase()}:${t.label || ''}:${t.parentId || ''}:${t.segmentId || ''}`;
    const map = new Map<string, TagItem>();
    
    // Include ALL tags (both user and API, all segments)
    [...userTags, ...apiTags].forEach((t) => map.set(key(t), t));
    return Array.from(map.values());
  }, [userTags, apiTags]);

  /**
   * ============================================================================
   * HOOK RETURN: Expose all state and actions
   * ============================================================================
   */
  return {
    // Tag management
    combinedTags,          // Merged user + API tags (filtered by segmentId for display)
    allTags,               // All tags regardless of segmentId (for saving)
    addCustomTag,          // Add user tag
    deleteTag,             // Delete any tag
    replaceAllTags,        // Replace all tags (for loading)
    runClassify,           // Call classification API
    tagTableRef,           // Ref for scrolling tag panel
    customTagInput,        // Input field state
    setCustomTagInput,     // Input field setter
  };
}
