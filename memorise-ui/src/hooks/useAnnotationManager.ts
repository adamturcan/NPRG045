import { useState, useEffect, useMemo, useCallback } from "react";
import type { NerSpan } from "../types/NotationEditor";
import type { Workspace } from "../types/Workspace";

/**
 * Create a unique key for an NER span (for comparison/deduplication)
 */
const keyOfSpan = (s: NerSpan) => `${s.start}:${s.end}:${s.entity}`;

/**
 * Options for useAnnotationManager hook
 */
interface AnnotationManagerOptions {
  /** Initial user spans (from workspace) */
  initialUserSpans?: NerSpan[];
  /** Initial API spans (from workspace) */
  initialApiSpans?: NerSpan[];
  /** Initial deleted API keys (from workspace) */
  initialDeletedKeys?: string[];
  /** Workspace ID - triggers hydration when it changes */
  hydrateKey?: string | null;
  /** Active tab: "original" or language code - determines which spans to load */
  activeTab?: string;
  /** Current workspace data (for hydration) */
  workspace?: Workspace;
  /** Callback to show notifications */
  onNotice?: (msg: string) => void;
  /** Workspace setter (for saving after NER) */
  setWorkspaces?: React.Dispatch<React.SetStateAction<Workspace[]>>;
}

/**
 * Hook for managing NER (Named Entity Recognition) annotation spans
 * 
 * Manages spans from two sources:
 * - User spans: Manually created by user in editor
 * - API spans: Generated by ML NER API
 * 
 * Features:
 * - Soft deletion of API spans (hidden but not removed)
 * - Automatic hydration when workspace changes
 * - Derived data (filtered spans, combined spans, deletable keys)
 * - NER API integration
 * 
 * @param options - Configuration options
 * @returns Object with span state, handlers, and derived data
 */
export function useAnnotationManager(options: AnnotationManagerOptions = {}) {
  const {
    initialUserSpans = [],
    initialApiSpans = [],
    initialDeletedKeys = [],
    hydrateKey,
    activeTab = "original",
    workspace,
    onNotice,
    setWorkspaces,
  } = options;

  /**
   * User-created spans (manually annotated)
   */
  const [userSpans, setUserSpans] = useState<NerSpan[]>(initialUserSpans);
  
  /**
   * API-generated spans (from NER ML model)
   */
  const [apiSpans, setApiSpans] = useState<NerSpan[]>(initialApiSpans);
  
  /**
   * Set of span keys that user has "deleted" (hidden from view)
   * Allows soft-delete of API spans without removing from workspace
   */
  const [deletedApiKeys, setDeletedApiKeys] = useState<Set<string>>(
    new Set(initialDeletedKeys)
  );

  /**
   * Hydration effect: Load spans from workspace when it changes
   * 
   * Runs when hydrateKey or activeTab changes.
   * Loads spans from the current workspace (original tab or translation tab).
   * Each translation has its own spans stored separately.
   */
  useEffect(() => {
    if (!hydrateKey || !workspace) return;

    let userSpansToLoad: NerSpan[] = [];
    let apiSpansToLoad: NerSpan[] = [];
    let deletedKeysToLoad: string[] = [];

    if (activeTab === "original") {
      // Load original text and spans
      userSpansToLoad = (workspace.userSpans as NerSpan[]) ?? [];
      apiSpansToLoad = (workspace.apiSpans as NerSpan[]) ?? [];
      deletedKeysToLoad = workspace.deletedApiKeys ?? [];
    } else {
      // Load translation text and spans
      const translation = workspace.translations?.find(
        (t) => t.language === activeTab
      );
      userSpansToLoad = (translation?.userSpans as NerSpan[]) ?? [];
      apiSpansToLoad = (translation?.apiSpans as NerSpan[]) ?? [];
      deletedKeysToLoad = translation?.deletedApiKeys ?? [];
    }

    setUserSpans(userSpansToLoad);
    setApiSpans(apiSpansToLoad);
    setDeletedApiKeys(new Set(deletedKeysToLoad));
  }, [hydrateKey, activeTab, workspace]);

  /**
   * Filter out API spans that user has soft-deleted
   * (deletedApiKeys contains keys of hidden spans)
   */
  const filteredApiSpans = useMemo(
    () => apiSpans.filter((s) => !deletedApiKeys.has(keyOfSpan(s))),
    [apiSpans, deletedApiKeys]
  );

  /**
   * Combine visible API spans with user spans for editor display
   */
  const combinedSpans = useMemo<NerSpan[]>(
    () => [...filteredApiSpans, ...userSpans],
    [filteredApiSpans, userSpans]
  );

  /**
   * Set of all span keys that can be deleted
   * Used by editor to show delete options
   */
  const deletableKeys = useMemo(() => {
    const keys = new Set<string>();
    filteredApiSpans.forEach((s) => keys.add(keyOfSpan(s)));
    userSpans.forEach((s) => keys.add(keyOfSpan(s)));
    return keys;
  }, [filteredApiSpans, userSpans]);

  /**
   * Delete a span (called from editor)
   * 
   * Strategy:
   * - If it's a user span: Remove from userSpans (hard delete)
   * - If it's an API span: Add to deletedApiKeys (soft delete)
   * 
   * Soft-delete for API spans allows them to reappear if user re-runs NER.
   */
  const deleteSpan = useCallback(
    (span: NerSpan) => {
      const k = keyOfSpan(span);
      
      if (userSpans.some((s) => keyOfSpan(s) === k)) {
        // Hard delete user spans
        setUserSpans((prev) => prev.filter((s) => keyOfSpan(s) !== k));
      } else {
        // Soft delete API spans
        setDeletedApiKeys((prev) => new Set(prev).add(k));
      }
    },
    [userSpans]
  );

  /**
   * Add or update a span (called from editor when user annotates text)
   * 
   * Flow:
   * 1. Remove from deletedApiKeys (in case it was soft-deleted)
   * 2. Add to userSpans (prevent duplicates)
   * 
   * Called when user manually annotates text or changes entity type.
   */
  const addSpan = useCallback(
    (span: NerSpan) => {
      const k = keyOfSpan(span);
      
      // Un-delete if it was soft-deleted
      setDeletedApiKeys((prev) => {
        const next = new Set(prev);
        next.delete(k);
        return next;
      });
      
      // Add to user spans (avoid duplicates)
      setUserSpans((prev) => {
        if (prev.some((s) => keyOfSpan(s) === k)) return prev;
        return [...prev, span];
      });
    },
    []
  );

  /**
   * Run NER API to automatically detect and annotate entities
   * 
   * Flow:
   * 1. Call NER API with current text (from active tab)
   * 2. Update apiSpans state
   * 3. Clear deletedApiKeys (show all new results)
   * 4. Save to workspace (if workspaceId and setWorkspaces provided)
   *    - If original tab: save to workspace root
   *    - If translation tab: save to that translation's data
   * 5. Show success notification
   * 
   * Replaces API spans but preserves user spans.
   * Each translation has its own separate NER spans.
   */
  const runNer = useCallback(
    async (text: string, workspaceId?: string | null) => {
      if (!text.trim()) {
        onNotice?.("Paste some text before running NER.");
        return;
      }
      
      try {
        // Call NER API directly
        const { ner: apiNer } = await import("../lib/api");
        const data = await apiNer(text) as { result?: Array<{ start: number; end: number; type: string }> };
        
        // Transform API response into NerSpan array
        const spans = (data.result ?? []).map((r) => ({
          start: r.start,
          end: r.end,
          entity: r.type, // API returns 'type' field, map to 'entity'
          score: 1.0, // API doesn't provide score, use default
        }));
        
        setApiSpans(spans);
        
        // Clear deletedApiKeys when running new NER to show all new results
        setDeletedApiKeys(new Set());
        
        // Save to workspace (if callbacks provided)
        // Save to correct location based on activeTab (original or translation)
        if (workspaceId && setWorkspaces) {
          setWorkspaces((prev) =>
            prev.map((w) => {
              if (w.id !== workspaceId) return w;
              
              if (activeTab === "original") {
                // Save to workspace root for original tab
                return {
                  ...w,
                  apiSpans: spans,
                  deletedApiKeys: [],
                  updatedAt: Date.now(),
                };
              } else {
                // Save to translation for translation tab
                const translations = w.translations || [];
                const translationIndex = translations.findIndex(
                  (t) => t.language === activeTab
                );
                
                if (translationIndex >= 0) {
                  // Update existing translation
                  const updatedTranslations = [...translations];
                  updatedTranslations[translationIndex] = {
                    ...updatedTranslations[translationIndex],
                    apiSpans: spans,
                    deletedApiKeys: [],
                    updatedAt: Date.now(),
                  };
                  return {
                    ...w,
                    translations: updatedTranslations,
                    updatedAt: Date.now(),
                  };
                } else {
                  // Translation not found (shouldn't happen, but handle gracefully)
                  return w;
                }
              }
            })
          );
        }
        
        onNotice?.("NER completed.");
      } catch (error) {
        console.error('NER failed:', error);
        onNotice?.("NER failed. Try again.");
      }
    },
    [onNotice, setWorkspaces, activeTab]
  );

  return {
    // State
    userSpans,
    apiSpans,
    deletedApiKeys,
    
    // Derived data
    filteredApiSpans,
    combinedSpans,
    deletableKeys,
    
    // Handlers
    addSpan,
    deleteSpan,
    runNer,
    
    // Setters (for external control if needed)
    setUserSpans,
    setApiSpans,
    setDeletedApiKeys,
  };
}

