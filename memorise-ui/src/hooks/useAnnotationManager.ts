import { useState, useEffect, useMemo, useCallback, useRef } from "react";
import type { NerSpan } from "../types/NotationEditor";
import type { Workspace } from "../types/Workspace";
import type { NoticeOptions } from "../types/Notice";
import {
  resolveApiSpanConflicts,
  type ConflictPrompt,
} from "../core/services/annotation/resolveApiSpanConflicts";
import { errorHandlingService } from "../infrastructure/services/ErrorHandlingService";
import { getApiService } from "../infrastructure/providers/apiProvider";

/**
 * Create a unique key for an NER span (for comparison/deduplication)
 */
const keyOfSpan = (s: NerSpan) => `${s.start}:${s.end}:${s.entity}`;

/**
 * Options for useAnnotationManager hook
 */
interface AnnotationManagerOptions {
  /** Initial user spans (from workspace) */
  initialUserSpans?: NerSpan[];
  /** Initial API spans (from workspace) */
  initialApiSpans?: NerSpan[];
  /** Initial deleted API keys (from workspace) */
  initialDeletedKeys?: string[];
  /** Workspace ID - triggers hydration when it changes */
  hydrateKey?: string | null;
  /** Active tab: "original" or language code - determines which spans to load */
  activeTab?: string;
  /** Current workspace data (for hydration) */
  workspace?: Workspace;
  /** Callback to show notifications */
  onNotice?: (msg: string, options?: NoticeOptions) => void;
  /** Workspace setter (for saving after NER) */
  setWorkspaces?: React.Dispatch<React.SetStateAction<Workspace[]>>;
}

/**
 * Hook for managing NER (Named Entity Recognition) annotation spans
 * 
 * Manages spans from two sources:
 * - User spans: Manually created by user in editor
 * - API spans: Generated by ML NER API
 * 
 * Features:
 * - Soft deletion of API spans (hidden but not removed)
 * - Automatic hydration when workspace changes
 * - Derived data (filtered spans, combined spans, deletable keys)
 * - NER API integration
 * 
 * @param options - Configuration options
 * @returns Object with span state, handlers, and derived data
 */
export function useAnnotationManager(options: AnnotationManagerOptions = {}) {
  const apiService = useMemo(() => getApiService(), []);

  const {
    initialUserSpans = [],
    initialApiSpans = [],
    initialDeletedKeys = [],
    hydrateKey,
    activeTab = "original",
    workspace,
    onNotice,
    setWorkspaces,
  } = options;

  /**
   * User-created spans (manually annotated)
   */
  const [userSpans, setUserSpans] = useState<NerSpan[]>(initialUserSpans);
  
  /**
   * API-generated spans (from NER ML model)
   */
  const [apiSpans, setApiSpans] = useState<NerSpan[]>(initialApiSpans);
  
  /**
   * Set of span keys that user has "deleted" (hidden from view)
   * Allows soft-delete of API spans without removing from workspace
   */
  const [deletedApiKeys, setDeletedApiKeys] = useState<Set<string>>(
    new Set(initialDeletedKeys)
  );

  const [conflictPrompt, setConflictPrompt] = useState<ConflictPrompt | null>(
    null
  );
  const conflictResolverRef = useRef<((choice: "api" | "existing") => void) | null>(
    null
  );

  const requestConflictResolution = useCallback(
    (prompt: ConflictPrompt) =>
      new Promise<"api" | "existing">((resolve) => {
        conflictResolverRef.current = (choice) => {
          resolve(choice);
          conflictResolverRef.current = null;
        };
        setConflictPrompt(prompt);
      }),
    []
  );

  const resolveConflictPrompt = useCallback((choice: "api" | "existing") => {
    conflictResolverRef.current?.(choice);
    setConflictPrompt(null);
    conflictResolverRef.current = null;
  }, []);

  /**
   * Keep workspace ref to avoid infinite loops when workspace object reference changes
   * Update ref when workspace actually changes (by ID comparison)
   */
  const workspaceRef = useRef<Workspace | undefined>(workspace);
  
  useEffect(() => {
    // Only update ref if workspace ID changed (actual workspace change)
    // Don't update if just the object reference changed but it's the same workspace
    if (workspace && workspace.id !== workspaceRef.current?.id) {
      workspaceRef.current = workspace;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [workspace?.id]); // Only depend on workspace ID, not entire object to avoid infinite loops

  /**
   * Hydration effect: Load spans from workspace when it changes
   * 
   * Runs when hydrateKey or activeTab changes.
   * Loads spans from the current workspace (original tab or translation tab).
   * Each translation has its own spans stored separately.
   */
  useEffect(() => {
    if (!hydrateKey || !workspace) return;

    let userSpansToLoad: NerSpan[] = [];
    let apiSpansToLoad: NerSpan[] = [];
    let deletedKeysToLoad: string[] = [];

    if (activeTab === "original") {
      // Load original text and spans
      userSpansToLoad = (workspace.userSpans as NerSpan[]) ?? [];
      apiSpansToLoad = (workspace.apiSpans as NerSpan[]) ?? [];
      deletedKeysToLoad = workspace.deletedApiKeys ?? [];
    } else {
      // Load translation text and spans
      const translation = workspace.translations?.find(
        (t) => t.language === activeTab
      );
      userSpansToLoad = (translation?.userSpans as NerSpan[]) ?? [];
      apiSpansToLoad = (translation?.apiSpans as NerSpan[]) ?? [];
      deletedKeysToLoad = translation?.deletedApiKeys ?? [];
    }

    setUserSpans(userSpansToLoad);
    setApiSpans(apiSpansToLoad);
    setDeletedApiKeys(new Set(deletedKeysToLoad));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [hydrateKey, activeTab, workspace?.id]); // Only depend on workspace ID to avoid infinite loops

  /**
   * Filter out API spans that user has soft-deleted
   * (deletedApiKeys contains keys of hidden spans)
   */
  const filteredApiSpans = useMemo(
    () => apiSpans.filter((s) => !deletedApiKeys.has(keyOfSpan(s))),
    [apiSpans, deletedApiKeys]
  );

  /**
   * Combine visible API spans with user spans for editor display
   */
  const combinedSpans = useMemo<NerSpan[]>(
    () => [...filteredApiSpans, ...userSpans],
    [filteredApiSpans, userSpans]
  );

  /**
   * Set of all span keys that can be deleted
   * Used by editor to show delete options
   */
  const deletableKeys = useMemo(() => {
    const keys = new Set<string>();
    filteredApiSpans.forEach((s) => keys.add(keyOfSpan(s)));
    userSpans.forEach((s) => keys.add(keyOfSpan(s)));
    return keys;
  }, [filteredApiSpans, userSpans]);

  /**
   * Delete a span (called from editor)
   * 
   * Strategy:
   * - If it's a user span: Remove from userSpans (hard delete)
   * - If it's an API span: Add to deletedApiKeys (soft delete)
   * 
   * Soft-delete for API spans allows them to reappear if user re-runs NER.
   */
  const deleteSpan = useCallback(
    (span: NerSpan) => {
      const k = keyOfSpan(span);
      
      if (userSpans.some((s) => keyOfSpan(s) === k)) {
        // Hard delete user spans
        setUserSpans((prev) => prev.filter((s) => keyOfSpan(s) !== k));
      } else {
        // Soft delete API spans
        setDeletedApiKeys((prev) => new Set(prev).add(k));
      }
    },
    [userSpans]
  );

  /**
   * Add or update a span (called from editor when user annotates text)
   * 
   * Flow:
   * 1. Remove from deletedApiKeys (in case it was soft-deleted)
   * 2. Add to userSpans (prevent duplicates)
   * 
   * Called when user manually annotates text or changes entity type.
   */
  const addSpan = useCallback(
    (span: NerSpan) => {
      const k = keyOfSpan(span);
      
      // Un-delete if it was soft-deleted
      setDeletedApiKeys((prev) => {
        const next = new Set(prev);
        next.delete(k);
        return next;
      });
      
      // Add to user spans (avoid duplicates)
      setUserSpans((prev) => {
        if (prev.some((s) => keyOfSpan(s) === k)) return prev;
        return [...prev, span];
      });
    },
    []
  );

  /**
   * Run NER API to automatically detect and annotate entities
   * 
   * Flow:
   * 1. Call NER API with current text (from active tab)
   * 2. Update apiSpans state
   * 3. Clear deletedApiKeys (show all new results)
   * 4. Save to workspace (if workspaceId and setWorkspaces provided)
   *    - If original tab: save to workspace root
   *    - If translation tab: save to that translation's data
   * 5. Show success notification
   * 
   * Replaces API spans but preserves user spans.
   * Each translation has its own separate NER spans.
   */
  const runNer = useCallback(
    async (text: string, workspaceId?: string | null) => {
      if (!text.trim()) {
        onNotice?.("Paste some text before running NER.");
        return;
      }

      try {
        const { nextUserSpans, nextApiSpans, conflictsHandled } =
          await resolveApiSpanConflicts({
            text,
            incomingSpans: await apiService.ner(text),
            userSpans,
            existingApiSpans: filteredApiSpans,
            onConflict: requestConflictResolution,
          });

        setUserSpans(nextUserSpans);
        setApiSpans(nextApiSpans);
        setDeletedApiKeys(new Set());

        if (workspaceId && setWorkspaces) {
          setWorkspaces((prev) =>
            prev.map((workspaceItem) => {
              if (workspaceItem.id !== workspaceId) return workspaceItem;

              if (activeTab === "original") {
                return {
                  ...workspaceItem,
                  userSpans: nextUserSpans,
                  apiSpans: nextApiSpans,
                  deletedApiKeys: [],
                  updatedAt: Date.now(),
                };
              }

              const translations = workspaceItem.translations || [];
              const translationIndex = translations.findIndex(
                (translation) => translation.language === activeTab
              );

              if (translationIndex < 0) {
                return workspaceItem;
              }

              const updatedTranslations = [...translations];
              updatedTranslations[translationIndex] = {
                ...updatedTranslations[translationIndex],
                userSpans: nextUserSpans,
                apiSpans: nextApiSpans,
                deletedApiKeys: [],
                updatedAt: Date.now(),
              };

              return {
                ...workspaceItem,
                translations: updatedTranslations,
                updatedAt: Date.now(),
              };
            })
          );
        }

        onNotice?.(
          conflictsHandled > 0
            ? "NER completed with conflicts â€” duplicates were resolved."
            : "NER completed."
        );
      } catch (error) {
        const appError = errorHandlingService.handleApiError(error, {
          operation: "run NER",
          hook: "useAnnotationManager",
          workspaceId,
          activeTab,
        });
        errorHandlingService.logError(appError, {
          hook: "useAnnotationManager",
          action: "runNer",
        });
        onNotice?.(appError.message, { tone: "error" });
      }
    },
    [
      activeTab,
      apiService,
      filteredApiSpans,
      onNotice,
      requestConflictResolution,
      setWorkspaces,
      userSpans,
    ]
  );

  return {
    // State
    userSpans,
    apiSpans,
    deletedApiKeys,
    conflictPrompt,
    
    // Derived data
    filteredApiSpans,
    combinedSpans,
    deletableKeys,
    
    // Handlers
    addSpan,
    deleteSpan,
    runNer,
    resolveConflictPrompt,
    
    // Setters (for external control if needed)
    setUserSpans,
    setApiSpans,
    setDeletedApiKeys,
  };
}

