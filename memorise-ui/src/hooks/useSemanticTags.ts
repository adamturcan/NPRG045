/**
 * useSemanticTags - Custom hook for managing semantic tags/keywords
 * 
 * This hook manages topic/keyword tags for text documents:
 * - User-added tags (manually entered keywords)
 * - API-generated tags (automatic suggestions via classification API)
 * - Workspace hydration (loading saved tags when switching workspaces)
 * 
 * ARCHITECTURE:
 * 
 * Tags come from two sources:
 * 1. "user" - manually added by the user via TagInput
 * 2. "api" - automatically suggested by the classification API
 * 
 * Both are stored separately but merged for display. This allows:
 * - Preserving user tags when re-running classification
 * - Distinguishing between manual and automatic tags
 * - Easy filtering/clearing of API-generated tags
 */
import { useCallback, useMemo, useRef, useState, useEffect } from "react";
import type { TagItem } from "../types/Tag";
import type { ThesaurusIndexItem } from "../types/Thesaurus";
import { loadThesaurusIndex, findInThesaurus } from "../lib/thesaurusHelpers";

type Options = {
  initialTags?: TagItem[];
  /** Changes when a different workspace is selected; triggers hydration */
  hydrateKey?: string | null;
};

export function useSemanticTags(opts?: Options) {
  // Tags are stored separately by source
  // User tags: manually added by the user
  const [userTags, setUserTags] = useState<TagItem[]>([]);
  // API tags: generated by the classification API
  const [apiTags, setApiTags] = useState<TagItem[]>([]);
  
  // Input field state for custom tag entry
  const [customTagInput, setCustomTagInput] = useState("");

  // Ref to the tag table scroll container (for scrolling to top after classification)
  const tagTableRef = useRef<HTMLDivElement>(null);

  /**
   * ============================================================================
   * WORKSPACE HYDRATION: Load saved tags when switching workspaces
   * ============================================================================
   * 
   * This effect runs when hydrateKey changes (typically the workspace ID).
   * It loads the saved tags from the workspace and separates them by source.
   * 
   * BUG FIX: Only trigger hydration when workspace ID changes, not when tags update.
   * If we include initialTags in dependencies, we create a circular loop:
   * 1. runClassify updates apiTags -> combinedTags changes
   * 2. WorkspaceContainer saves tags -> workspace.tags changes -> initialTags changes
   * 3. Hydration effect runs -> resets apiTags/userTags -> combinedTags changes
   * 4. Loop continues infinitely
   * 
   * Solution: Only depend on hydrateKey (workspace ID). Read initialTags inside
   * the effect but don't include it in dependencies. Use a ref to track last
   * hydrated workspace to prevent unnecessary re-hydrations.
   */
  const lastHydratedWorkspaceRef = useRef<string | null>(null);

  useEffect(() => {
    // Reset ref when no workspace is selected (allows re-hydration when workspace is selected again)
    if (!opts?.hydrateKey) {
      lastHydratedWorkspaceRef.current = null;
      // Clear tags when no workspace is selected
      setUserTags([]);
      setApiTags([]);
      return;
    }
    
    // Only hydrate when workspace ID changes, not when tags in workspace update
    if (lastHydratedWorkspaceRef.current === opts.hydrateKey) {
      return;
    }
    
    // Mark this workspace as hydrated
    lastHydratedWorkspaceRef.current = opts.hydrateKey;
    
    // Always read the current value of initialTags (not from closure)
    // This ensures we get the tags for the NEW workspace, not the old one
    // Handle undefined/null/empty explicitly for new workspaces that don't have tags initialized
    // If initialTags is undefined, null, or not an array, treat as empty (no tags)
    const tags = Array.isArray(opts?.initialTags) ? opts.initialTags : [];
    const u = tags.filter((t) => t.source === "user");
    const a = tags.filter((t) => t.source === "api");
    
    // ALWAYS reset tags when workspace changes (even if empty arrays)
    // This clears previous workspace tags and loads new workspace tags
    // Empty arrays ensure empty workspaces don't inherit tags from previous workspace
    setUserTags(u);
    setApiTags(a);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    opts?.hydrateKey // Only depend on workspace ID, not on initialTags (prevents infinite loop when tags update)
  ]);

  /**
   * ============================================================================
   * DERIVED STATE: Merge tags from both sources
   * ============================================================================
   * 
   * Combines user tags and API tags into a single array, removing duplicates.
   * A tag is considered duplicate if it has the same name (case-insensitive)
   * from the same source.
   */
  const combinedTags: TagItem[] = useMemo(() => {
    const key = (t: TagItem) => `${t.source}:${t.name.toLowerCase()}:${t.label || ''}:${t.parentId || ''}`;
    const map = new Map<string, TagItem>();
    // User tags appear first in the array
    [...userTags, ...apiTags].forEach((t) => map.set(key(t), t));
    return Array.from(map.values());
  }, [userTags, apiTags]);

  /**
   * ============================================================================
   * TAG ACTIONS: Add, delete, replace
   * ============================================================================
   */

  /**
   * Add a custom user tag
   * Prevents duplicates (case-insensitive) and empty tags
   * Also looks up KeywordID and ParentID from thesaurus if available
   * Automatically restructures tags to create hierarchical relationships
   */
  const addCustomTag = useCallback(
    async (name: string, keywordId?: number, parentId?: number) => {
      const tag = name.trim();
      if (!tag) return;
      
      // Check if this exact tag already exists (name + keywordId + parentId)
      // Allow same name in different hierarchies (different parentId)
      const exists = combinedTags.some((t) => {
        const nameMatch = t.name.toLowerCase() === tag.toLowerCase();
        
        // If neither has IDs, just check name (custom tags without thesaurus)
        if (!t.label && !keywordId) return nameMatch;
        
        // If both have IDs, check name + keywordId + parentId
        if (t.label && keywordId) {
          return nameMatch && t.label === keywordId && t.parentId === parentId;
        }
        
        // One has ID, one doesn't - treat as different tags
        return false;
      });
      
      if (exists) return;
      
      // Use provided keywordId/parentId or try to find them from thesaurus
      let finalKeywordId: number | undefined = keywordId;
      let finalParentId: number | undefined = parentId;
      let thesaurusIndex: ThesaurusIndexItem[] | undefined;
      
      if (!finalKeywordId) {
        // No keywordId provided, look up in thesaurus by name
        try {
          thesaurusIndex = await loadThesaurusIndex();
          const entry = findInThesaurus({ name: tag }, thesaurusIndex);
          finalKeywordId = entry?.id;
          finalParentId = entry?.parentId;
        } catch {
          // Thesaurus not available, that's fine
          finalKeywordId = undefined;
          finalParentId = undefined;
        }
      } else if (!finalParentId) {
        // KeywordId provided but no parentId, look up parentId
        try {
          thesaurusIndex = await loadThesaurusIndex();
          const entry = findInThesaurus({ name: tag, keywordId: finalKeywordId }, thesaurusIndex);
          finalParentId = entry?.parentId;
        } catch {
          // Thesaurus not available, that's fine
          finalParentId = undefined;
        }
      }
      
      // Add the new tag to user tags
      const newTag = { 
        name: tag, 
        source: "user" as const,
        label: finalKeywordId,    // Include KeywordID if found
        parentId: finalParentId,  // Include ParentID if found (disambiguates duplicates)
      };
      
      // Simply add the new tag - let the TagTable handle hierarchy building
      setUserTags((prev) => [newTag, ...prev]);
    },
    [combinedTags]
  );

  /**
   * Delete a tag by name and context (keywordId + parentId)
   * Removes the specific tag instance from both user and API tags
   */
  const deleteTag = useCallback((name: string, keywordId?: number, parentId?: number) => {
    // Filter out the specific tag instance based on name + keywordId + parentId
    setUserTags((prev) => prev.filter((t) => {
      const nameMatch = t.name === name;
      if (!nameMatch) return true;
      
      // If no IDs provided, match by name only (backward compatibility)
      if (keywordId === undefined && parentId === undefined) return false;
      
      // Match by name + keywordId + parentId
      return !(t.label === keywordId && t.parentId === parentId);
    }));
    
    setApiTags((prev) => prev.filter((t) => {
      const nameMatch = t.name === name;
      if (!nameMatch) return true;
      
      // If no IDs provided, match by name only (backward compatibility)
      if (keywordId === undefined && parentId === undefined) return false;
      
      // Match by name + keywordId + parentId
      return !(t.label === keywordId && t.parentId === parentId);
    }));
  }, []);

  /**
   * Replace all tags (used when loading from workspace)
   * Separates by source and updates both states
   */
  const replaceAllTags = useCallback((tags: TagItem[]) => {
    const u = tags.filter((t) => t.source === "user");
    const a = tags.filter((t) => t.source === "api");
    setUserTags(u);
    setApiTags(a);
  }, []);

  /**
   * ============================================================================
   * CLASSIFICATION API: Automatic tag generation
   * ============================================================================
   */

  /**
   * Call the classification API to generate tag suggestions
   * Replaces all API tags with new results (preserves user tags)
   * For duplicate KeywordIDs, adds ALL instances from thesaurus
   * Scrolls the tag panel to top after completion
   */
  const runClassify = useCallback(async (text: string) => {
    if (!text.trim()) return;
    
    // Call the classification API
    const { classify: apiClassify } = await import("../lib/api");
    const data = await apiClassify(text);
    
    // Transform API response into TagItem array
    // API returns 'label' field which is the KeywordID from thesaurus
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const apiResults: any[] = data.results || [];
    
    // Expand duplicate KeywordIDs into multiple tags
    const newTags: TagItem[] = [];
    
    for (const r of apiResults) {
      const keywordId = r.label;
      const name = r.name;
      
      // Check if user already has this tag (by name)
      const userAlreadyHas = userTags.some(t => t.name.toLowerCase() === name.toLowerCase());
      if (userAlreadyHas) {
        // Skip this tag - user version takes precedence
        continue;
      }
      
      if (keywordId) {
        // Try to find all instances of this KeywordID in the thesaurus
        try {
          const thesaurusIndex = await loadThesaurusIndex();
          const matches = thesaurusIndex.filter(item => item.id === keywordId);
          
          if (matches.length > 1) {
            // Multiple instances found - add all of them (if not already added by user)
            for (const match of matches) {
              const matchName = match.label.toLowerCase();
              const userHasThisInstance = userTags.some(t => 
                t.name.toLowerCase() === matchName && 
                t.label === match.id && 
                t.parentId === match.parentId
              );
              
              if (!userHasThisInstance) {
                newTags.push({
                  name: match.label, // Use thesaurus label (might be different from API name)
                  source: "api" as const,
                  label: match.id,
                  parentId: match.parentId,
                });
              }
            }
          } else if (matches.length === 1) {
            // Single instance - check if user already has this exact instance
            const match = matches[0];
            const userHasThisInstance = userTags.some(t => 
              t.name.toLowerCase() === match.label.toLowerCase() && 
              t.label === match.id && 
              t.parentId === match.parentId
            );
            
            if (!userHasThisInstance) {
              newTags.push({
                name: match.label,
                source: "api" as const,
                label: match.id,
                parentId: match.parentId,
              });
            }
          } else {
            // No thesaurus match - add as-is (fallback) if user doesn't have it
            newTags.push({
              name: name,
              source: "api" as const,
              label: keywordId,
            });
          }
        } catch {
          // Thesaurus not available - add as-is (fallback) if user doesn't have it
          newTags.push({
            name: name,
            source: "api" as const,
            label: keywordId,
          });
        }
      } else {
        // No KeywordID - add as-is if user doesn't have it
        newTags.push({
          name: name,
          source: "api" as const,
        });
      }
    }
    
    // Replace API tags (user tags remain unchanged)
    setApiTags(newTags);
    
    // Scroll tag panel to top to show new results
    setTimeout(
      () => tagTableRef.current?.scrollTo({ top: 0, behavior: "smooth" }),
      100
    );
  }, [userTags]);

  /**
   * ============================================================================
   * HOOK RETURN: Expose all state and actions
   * ============================================================================
   */
  return {
    // Tag management
    combinedTags,          // Merged user + API tags
    addCustomTag,          // Add user tag
    deleteTag,             // Delete any tag
    replaceAllTags,        // Replace all tags (for loading)
    runClassify,           // Call classification API
    tagTableRef,           // Ref for scrolling tag panel
    customTagInput,        // Input field state
    setCustomTagInput,     // Input field setter
  };
}
