// src/components/containers/WorkspaceContainer.tsx
/**
 * WorkspaceContainer - Container component for workspace editing and annotation
 * 
 * This container component manages all workspace-related logic and state:
 * - Workspace selection from route
 * - Editor state (text, editorInstanceKey)
 * - NER annotations (via useAnnotationManager)
 * - Translation tabs (via useTranslationManager)
 * - Auto-save (via useAutoSave)
 * - Tags (via useSemanticTags)
 * - Thesaurus (via useThesaurusWorker)
 * - ML API operations (classification, NER)
 * 
 * Uses the container/presentational pattern - this component contains all logic,
 * presentational components (BookmarkBar, EditorArea, RightPanel) only render UI.
 * 
 * ARCHITECTURE:
 * 
 * 1. Multi-Workspace Support:
 *    - Users can have multiple workspaces
 *    - Route parameter determines active workspace (URL: /workspace/:id)
 *    - Switching workspaces triggers hydration (loading saved data)
 * 
 * 2. Data Persistence:
 *    - Autosave: Changes saved automatically after 350ms delay
 *    - Manual Save: Cmd+S / Ctrl+S trigger immediate save
 *    - Workspaces stored in parent App component state
 * 
 * 3. NER Annotations (Two Sources):
 *    - User spans: Manually annotated by user in editor
 *    - API spans: Generated by ML NER model
 *    - Users can hide API spans without deleting (deletedApiKeys)
 * 
 * 4. Tags (Two Sources):
 *    - User tags: Manually entered keywords
 *    - API tags: Generated by classification ML model
 *    - Managed by useSemanticTags hook
 * 
 * 5. Layout:
 *    - Left: BookmarkBar + EditorArea (NotationEditor)
 *    - Right: RightPanel (tag management)
 *    - Bottom: Snackbar notifications
 */
import React, {
  useMemo,
  useState,
  useCallback,
  useEffect,
  useRef,
} from "react";
import {
  Box,
  Typography,
  useMediaQuery,
  useTheme,
  Snackbar,
  Alert,
} from "@mui/material";
import { useParams } from "react-router-dom";

import type { Workspace } from "../../types/Workspace";
import type { NerSpan } from "../../types/NotationEditor";

import BookmarkBar from "../workspace/BookmarkBar";
import EditorArea from "../workspace/EditorArea";
import RightPanel, { type TagRow } from "../right/RightPanel";
import type { ThesaurusItem } from "../tags/TagThesaurusInput";

import { useSemanticTags } from "../../hooks/useSemanticTags";
import { useThesaurusWorker } from "../../hooks/useThesaurusWorker";
import { useWorkspaceState } from "../../hooks/useWorkspaceState";
import { useAutoSave } from "../../hooks/useAutoSave";
import { useAnnotationManager } from "../../hooks/useAnnotationManager";
import { useTranslationManager } from "../../hooks/useTranslationManager";
import { loadThesaurusIndex } from "../../lib/thesaurusHelpers";
import type { ThesaurusIndexItem } from "../../types/Thesaurus";

interface Props {
  workspaces: Workspace[];
  setWorkspaces: React.Dispatch<React.SetStateAction<Workspace[]>>;
}

const COLORS = {
  text: "#0F172A",
  gold: "#DDD1A0",
};

const WorkspaceContainer: React.FC<Props> = ({ workspaces, setWorkspaces }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
  const { id: routeId } = useParams();

  /**
   * ============================================================================
   * WORKSPACE SELECTION
   * ============================================================================
   */

  /**
   * Workspace selection hook - finds current workspace from route parameter
   */
  const { currentWorkspace: currentWs, currentId } = useWorkspaceState(
    workspaces,
    routeId
  );

  /**
   * ============================================================================
   * EDITOR STATE
   * ============================================================================
   */

  /**
   * Key to force Slate editor remount on workspace change
   * Ensures clean selection & placeholder state
   */
  const [editorInstanceKey, setEditorInstanceKey] = useState<string>("");
  
  /**
   * Main text content being edited
   */
  const [text, setText] = useState<string>("");

  /**
   * ============================================================================
   * TAGS & NER MANAGEMENT (via custom hooks)
   * ============================================================================
   */

  /**
   * Semantic tags hook - manages user and API-generated tags
   * Automatically hydrates when currentId changes (hydrateKey)
   */
  const tags = useSemanticTags({
    initialTags: currentWs?.tags,
    hydrateKey: currentId,
  });

  /**
   * NER annotations hook - provides API functions for NER
   * Note: We manage spans locally for workspace persistence
   */
  // const ner = useNerAnnotations(); // Unused - kept for potential future use

  /**
   * Thesaurus worker - background search for 750k keywords
   * Loads index in Web Worker to prevent UI freezing
   */
  const thesaurusWorker = useThesaurusWorker();

  /**
   * Thesaurus index for hierarchical tag display
   * Load the same index for the UI (for grouping tags by hierarchy)
   */
  const [thesaurusIndexForDisplay, setThesaurusIndexForDisplay] = 
    useState<ThesaurusIndexItem[] | null>(null);

  // Load thesaurus index once when worker is ready
  useEffect(() => {
    if (thesaurusWorker.ready && !thesaurusIndexForDisplay) {
      loadThesaurusIndex()
        .then(setThesaurusIndexForDisplay)
        .catch(err => {
          console.error('Failed to load thesaurus for display:', err);
        });
    }
  }, [thesaurusWorker.ready, thesaurusIndexForDisplay]);

  /**
   * ============================================================================
   * BOOKMARKS & NOTIFICATIONS
   * ============================================================================
   */

  /**
   * Snackbar notification system (declared early for use in handlers)
   */
  const [notice, setNotice] = useState<string | null>(null);
  const showNotice = useCallback((msg: string) => setNotice(msg), []);

  /**
   * Ref to store annotations for use in translation hook getters
   * (avoids circular dependency during hook initialization)
   */
  const annotationsRef = useRef<{
    userSpans: NerSpan[];
    apiSpans: NerSpan[];
    deletedApiKeys: Set<string>;
  } | null>(null);

  /**
   * ============================================================================
   * TRANSLATION TAB SYSTEM (via custom hook)
   * ============================================================================
   * 
   * Manages:
   * - Active tab state (original vs translation languages)
   * - Translation menu anchor (for adding translations)
   * - Tab switching (saves current, loads new)
   * - Adding translations (with language detection)
   * - Updating translations (re-translation from original)
   * - Deleting translations
   * 
   * Each translation tab maintains its own text and NER spans.
   * 
   * Note: Initialized before annotations to provide activeTab value,
   * but uses refs for annotation getters to avoid circular dependency.
   */
  const translations = useTranslationManager({
    workspaceId: currentId ?? null,
    workspace: currentWs,
    getCurrentText: () => text,
    getUserSpans: () => annotationsRef.current?.userSpans ?? [],
    getApiSpans: () => annotationsRef.current?.apiSpans ?? [],
    getDeletedApiKeys: () => annotationsRef.current?.deletedApiKeys ?? new Set(),
    setText,
    setEditorInstanceKey,
    setWorkspaces,
    onNotice: showNotice,
  });

  /**
   * ============================================================================
   * NER SPANS MANAGEMENT (via custom hook)
   * ============================================================================
   * 
   * NER spans come from two sources:
   * - userSpans: Manually created by user in editor
   * - apiSpans: Generated by ML NER API
   * 
   * Managed by useAnnotationManager hook which handles:
   * - Preserving user annotations when re-running NER
   * - Allowing users to hide API spans without deleting them (soft delete)
   * - Automatic hydration when workspace changes
   * - Uses activeTab from translations hook to load correct spans per tab
   */
  const annotations = useAnnotationManager({
    initialUserSpans: currentWs?.userSpans as NerSpan[],
    initialApiSpans: currentWs?.apiSpans as NerSpan[],
    initialDeletedKeys: currentWs?.deletedApiKeys ?? [],
    hydrateKey: currentId,
    activeTab: translations.activeTab, // Use activeTab from translations hook
    workspace: currentWs,
    onNotice: showNotice,
    setWorkspaces,
  });
  
  // Update ref whenever annotations change (for use in translation hook getters)
  useEffect(() => {
    annotationsRef.current = {
      userSpans: annotations.userSpans,
      apiSpans: annotations.apiSpans,
      deletedApiKeys: annotations.deletedApiKeys,
    };
  }, [annotations.userSpans, annotations.apiSpans, annotations.deletedApiKeys]);

  /**
   * ============================================================================
   * AUTOSAVE HOOK
   * ============================================================================
   * 
   * Manages automatic and manual workspace saving with debouncing.
   * Handles hydration guard internally.
   */
  const autosave = useAutoSave(
    currentId ?? null,
    {
      text,
      userSpans: annotations.userSpans,
      apiSpans: annotations.apiSpans,
      deletedApiKeys: annotations.deletedApiKeys,
      tags: tags.combinedTags,
    },
    setWorkspaces,
    {
      delay: 350,
      enabled: true,
      activeTab: translations.activeTab,
    }
  );

  /**
   * ============================================================================
   * HYDRATION: Load workspace data when switching workspaces
   * ============================================================================
   * 
   * Runs when currentId changes (user switches workspace via URL).
   * 
   * Process:
   * 1. Block autosave (set hydratedIdRef to null via setHydrated)
   * 2. Load text, spans, and metadata from workspace
   * 3. Tags auto-hydrate via useSemanticTags hook (hydrateKey dep)
   * 4. Force Slate editor remount with new key
   * 5. Re-enable autosave (set hydratedIdRef to currentId via setHydrated)
   */
  useEffect(() => {
    if (!currentId) return;
    
    // Block autosave while loading
    autosave.setHydrated(null);

    // Reset to original tab when switching workspaces
    translations.setActiveTab("original");
    
    // Note: annotations hook will automatically re-hydrate with correct spans
    // because it depends on translations.activeTab

    // Load text content (ensure it's always a string)
    setText(currentWs?.text || "");
    
    // NER annotation spans are hydrated automatically via useAnnotationManager hook (hydrateKey dependency)
    // (Each translation has its own spans stored separately)

    // Tags are hydrated automatically via useSemanticTags hook (hydrateKey dependency)

    // Force Slate editor remount for clean state (prevents stale selections/placeholders)
    Promise.resolve().then(() => {
      autosave.setHydrated(currentId);
      setEditorInstanceKey(`${currentId}:${currentWs?.updatedAt ?? 0}`);
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentId]);

  /**
   * ============================================================================
   * MANUAL SAVE: Triggered by save button or keyboard shortcut
   * ============================================================================
   * 
   * Immediately saves all workspace data (no debounce).
   * Called by EditorArea when user presses Cmd+S/Ctrl+S or clicks save button.
   * 
   * Delegates to autosave hook's saveNow function.
   */
  const handleSave = useCallback(() => {
    autosave.saveNow(showNotice);
  }, [autosave, showNotice]);

  /**
   * ============================================================================
   * ML API OPERATIONS
   * ============================================================================
   */

  /**
   * Run classification API to generate tag suggestions
   * 
   * Flow:
   * 1. Call classification API with current text
   * 2. Hook updates its internal state with results
   * 3. Save new tags to workspace
   * 4. Show success notification
   * 
   * Replaces API tags but preserves user tags.
   */
  const handleRunClassify = useCallback(async () => {
    if (!text.trim()) {
      showNotice("Paste some text before running classify.");
      return;
    }
    
    // Call classification API via hook
    await tags.runClassify(text);
    
    // Note: Tags are automatically saved by useAutoSave hook (debounced)
    // No need to manually save here - autosave will handle it after delay
    
    showNotice("Classification completed.");
  }, [text, currentId, tags, showNotice]);

  /**
   * Run NER API to automatically detect and annotate entities
   * 
   * Delegates to useAnnotationManager hook's runNer function.
   * Replaces API spans but preserves user spans.
   */
  const handleRunNer = useCallback(async () => {
    await annotations.runNer(text, currentId ?? null);
  }, [text, currentId, annotations]);


  /**
   * ============================================================================
   * AUTO-SAVE: Save tags to workspace whenever they change
   * ============================================================================
   * 
   * NOTE: Tag saving is handled by useAutoSave hook (which includes hydration guard).
   * This section is intentionally empty - tags are saved automatically via autosave
   * with proper hydration protection.
   * 
   * The useAutoSave hook:
   * - Respects hydration guard (won't save during workspace switching)
   * - Includes tags in the debounced autosave
   * - Properly handles empty tag arrays (clears tags when deleted)
   */

  /**
   * ============================================================================
   * TAG HANDLERS
   * ============================================================================
   */

  /**
   * Add a user-created tag
   * Delegates to hook - workspace saving is handled by useEffect
   */
  const addCustomTag = useCallback(
    (name: string, keywordId?: number, parentId?: number) => {
      // Add the tag to state
      tags.addCustomTag(name, keywordId, parentId);
      // Note: Workspace saving is handled automatically by useEffect below
    },
    [tags]
  );

  /**
   * Delete a tag (user or API)
   * Delegates to hook - workspace saving is handled by useEffect
   */
  const deleteTag = useCallback(
    (name: string, keywordId?: number, parentId?: number) => {
      tags.deleteTag(name, keywordId, parentId);
      // Note: Workspace saving is handled automatically by useEffect above
    },
    [tags]
  );

  /**
   * ============================================================================
   * THESAURUS: Custom 750k keyword vocabulary search
   * ============================================================================
   * 
   * Searches your custom thesaurus using a Web Worker (background thread).
   * 
   * Strategy:
   * 1. Worker loads pre-processed index on startup
   * 2. Fuzzy search runs in background (doesn't freeze UI)
   * 3. Returns top 20 matches sorted by relevance
   * 
   * Used by TagThesaurusInput component in RightPanel.
   * 
   * Note: First search may take 1-2s while worker loads index.
   * Subsequent searches are instant (~50-100ms).
   */
  const fetchThesaurus = useCallback(
    async (q: string): Promise<ThesaurusItem[]> => {
      if (!q.trim()) return [];
      
      // Wait for worker to be ready (first load takes ~1-2 seconds)
      if (!thesaurusWorker.ready) {
        // Don't warn on every call, worker is still loading
        return [];
      }
      
      try {
        // Search in worker (non-blocking, runs in background thread)
        const results = await thesaurusWorker.search(q, 20);
        
        // Map to UI format
        return results.map(item => ({
          name: item.label,
          path: item.path,                    // Full hierarchical path
          keywordId: item.id,
          parentId: item.parentId,            // Parent ID to disambiguate duplicates
          isPreferred: item.isPreferred,
          depth: item.depth,
        }));
      } catch (error) {
        console.error('Thesaurus search error:', error);
        return [];
      }
    },
    [thesaurusWorker]
  );

  /**
   * ============================================================================
   * DERIVED DATA FOR UI
   * ============================================================================
   */

  /**
   * Convert tags to format for RightPanel
   * Includes keywordId and parentId if tag has them (from API classification or thesaurus)
   */
  const tagRows: TagRow[] = useMemo(
    () => tags.combinedTags.map((t) => ({ 
      name: t.name, 
      source: t.source,
      // If tag has a 'label' field from API, it's the KeywordID
      keywordId: t.label !== undefined ? Number(t.label) : undefined,
      // Include parentId to disambiguate duplicate KeywordIDs
      parentId: t.parentId,
    })),
    [tags.combinedTags]
  );

  /**
   * ============================================================================
   * RENDER
   * ============================================================================
   * 
   * Layout:
   * - Desktop: Two-column (editor left, tags right)
   * - Mobile: Single column stacked
   * 
   * Components:
   * - BookmarkBar: Quick access links (top of left column)
   * - EditorArea: Main text editor with NER annotations
   * - RightPanel: Tag management with thesaurus
   * - Snackbar: Floating notifications
   */
  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: isMobile ? "column" : "row",
        height: "100vh",
        overflow: "hidden",
        position: "relative",
        px: isMobile ? 0 : 4,
        color: COLORS.text,
      }}
    >
      {/* ========================================================================
          LEFT COLUMN: Editor
          ======================================================================== */}
      <Box
        sx={{
          flex: 1,
          boxSizing: "border-box",
          display: "flex",
          flexDirection: "column",
          height: "88.5vh",
          pl: 4,
          minHeight: 0,
        }}
      >
        {/* Translation tabs bar */}
        <BookmarkBar
          translationLanguages={translations.translationLanguages}
          activeTab={translations.activeTab}
          onTabClick={translations.onTabSwitch}
          onAddClick={translations.openMenu}
          anchorEl={translations.menuAnchor}
          onClose={translations.closeMenu}
          onSelectLanguage={translations.onAddTranslation}
          onDeleteTranslation={translations.onDeleteTranslation}
          onUpdateTranslation={translations.onUpdateTranslation}
        />

        {/* Main editor with text input, NER annotations, and action buttons */}
        <EditorArea
          editorInstanceKey={editorInstanceKey}
          text={text}
          setText={setText}
          onUpload={async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            const content = await file.text();
            setText(content);
          }}
          onClassify={handleRunClassify}
          onNer={handleRunNer}
          spans={annotations.combinedSpans}
          highlightedCategories={[]}
          deletableKeys={annotations.deletableKeys}
          onDeleteSpan={annotations.deleteSpan}
          onAddSpan={annotations.addSpan}
          onSave={handleSave}
        />
      </Box>

      {/* ========================================================================
          RIGHT COLUMN: Tag Management
          ======================================================================== */}
      <Box
        sx={{
          width: isMobile ? "100%" : "300px",
          boxSizing: "border-box",
          height: isMobile ? "60vh" : "86vh",
          display: "flex",
          flexDirection: "column",
          mt: isMobile ? 2 : 4,
          p: isMobile ? 2 : 0,
          pr: { xs: 0, sm: 1 },
          minHeight: 0,
          overflow: "visible",
          ml: { xs: 0, sm: 2 },
        }}
      >
        {!isMobile ? (
          // Desktop: Clean tag panel with hierarchical display
          <RightPanel
            tags={tagRows}
            onDeleteTag={deleteTag}
            thesaurus={{
              onAdd: (name, keywordId, parentId) => addCustomTag(name, keywordId, parentId),
              fetchSuggestions: fetchThesaurus,
              defaultRestrictToThesaurus: false,
              isThesaurusLoading: !thesaurusWorker.ready,
              resetKey: currentId,  // Force input reset when workspace changes
            }}
            thesaurusIndex={thesaurusIndexForDisplay || undefined}
          />
        ) : (
          // Mobile: Tag panel with title
          <>
            <Typography
              variant="h6"
              sx={{
                mb: 1,
                color: COLORS.gold,
                fontWeight: 900,
                textTransform: "uppercase",
                letterSpacing: 0.5,
                textShadow: "0 1px 2px rgba(0,0,0,0.35)",
              }}
            >
              Tags
            </Typography>
            <Box sx={{ flex: 1, minHeight: 0 }}>
              <RightPanel
                tags={tagRows}
                onDeleteTag={deleteTag}
                thesaurus={{
                  onAdd: (name, keywordId, parentId) => addCustomTag(name, keywordId, parentId),
                  fetchSuggestions: fetchThesaurus,
                  defaultRestrictToThesaurus: false,
                  isThesaurusLoading: !thesaurusWorker.ready,
                  resetKey: currentId,  // Force input reset when workspace changes
                }}
                thesaurusIndex={thesaurusIndexForDisplay || undefined}
              />
            </Box>
          </>
        )}
      </Box>

      {/* ========================================================================
          NOTIFICATIONS
          ======================================================================== */}
      <Snackbar
        open={!!notice}
        autoHideDuration={2200}
        onClose={() => setNotice(null)}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={() => setNotice(null)}
          severity="info"
          variant="filled"
          sx={{ bgcolor: "#21426C" }}
        >
          {notice}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default WorkspaceContainer;

