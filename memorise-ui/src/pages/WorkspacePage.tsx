// src/pages/WorkspacePage.tsx
/**
 * WorkspacePage - Main page for editing and annotating text documents
 * 
 * This is the primary workspace interface where users:
 * - Edit text content in a rich editor
 * - Annotate text with NER (Named Entity Recognition) spans
 * - Add semantic tags/keywords to documents
 * - Run ML classification and NER APIs
 * - Switch between multiple workspaces
 * 
 * ARCHITECTURE:
 * 
 * 1. Multi-Workspace Support:
 *    - Users can have multiple workspaces
 *    - Route parameter determines active workspace (URL: /workspace/:id)
 *    - Switching workspaces triggers hydration (loading saved data)
 * 
 * 2. Data Persistence:
 *    - Autosave: Changes saved automatically after 350ms delay
 *    - Manual Save: Cmd+S / Ctrl+S trigger immediate save
 *    - Workspaces stored in parent App component state
 * 
 * 3. NER Annotations (Two Sources):
 *    - User spans: Manually annotated by user in editor
 *    - API spans: Generated by ML NER model
 *    - Users can hide API spans without deleting (deletedApiKeys)
 * 
 * 4. Tags (Two Sources):
 *    - User tags: Manually entered keywords
 *    - API tags: Generated by classification ML model
 *    - Managed by useSemanticTags hook
 * 
 * 5. Layout:
 *    - Left: BookmarkBar + EditorArea (NotationEditor)
 *    - Right: RightPanel (tag management)
 *    - Bottom: Snackbar notifications
 */
import React, {
  useMemo,
  useState,
  useCallback,
  useEffect,
} from "react";
import {
  Box,
  Typography,
  useMediaQuery,
  useTheme,
  Snackbar,
  Alert,
} from "@mui/material";
import { useParams } from "react-router-dom";

import type { Workspace } from "../types/Workspace";
import type { NerSpan } from "../types/NotationEditor";

import BookmarkBar from "../components/workspace/BookmarkBar";
import EditorArea from "../components/workspace/EditorArea";
import RightPanel, { type TagRow } from "../components/right/RightPanel";
import type { ThesaurusItem } from "../components/tags/TagThesaurusInput";

import { useSemanticTags } from "../hooks/useSemanticTags";
import { useThesaurusWorker } from "../hooks/useThesaurusWorker";
import { useWorkspaceState } from "../hooks/useWorkspaceState";
import { useAutoSave } from "../hooks/useAutoSave";
import { useAnnotationManager } from "../hooks/useAnnotationManager";
import { loadThesaurusIndex } from "../lib/thesaurusHelpers";
import type { ThesaurusIndexItem } from "../types/Thesaurus";

interface Props {
  workspaces: Workspace[];
  setWorkspaces: React.Dispatch<React.SetStateAction<Workspace[]>>;
}

const COLORS = {
  text: "#0F172A",
  gold: "#DDD1A0",
};

const WorkspacePage: React.FC<Props> = ({ workspaces, setWorkspaces }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
  const { id: routeId } = useParams();

  /**
   * ============================================================================
   * WORKSPACE SELECTION
   * ============================================================================
   */

  /**
   * Workspace selection hook - finds current workspace from route parameter
   */
  const { currentWorkspace: currentWs, currentId } = useWorkspaceState(
    workspaces,
    routeId
  );

  /**
   * ============================================================================
   * EDITOR STATE
   * ============================================================================
   */

  /**
   * Key to force Slate editor remount on workspace change
   * Ensures clean selection & placeholder state
   */
  const [editorInstanceKey, setEditorInstanceKey] = useState<string>("");
  
  /**
   * Main text content being edited
   */
  const [text, setText] = useState<string>("");

  /**
   * ============================================================================
   * TAGS & NER MANAGEMENT (via custom hooks)
   * ============================================================================
   */

  /**
   * Semantic tags hook - manages user and API-generated tags
   * Automatically hydrates when currentId changes (hydrateKey)
   */
  const tags = useSemanticTags({
    initialTags: currentWs?.tags,
    hydrateKey: currentId,
  });

  /**
   * NER annotations hook - provides API functions for NER
   * Note: We manage spans locally for workspace persistence
   */
  // const ner = useNerAnnotations(); // Unused - kept for potential future use

  /**
   * Thesaurus worker - background search for 750k keywords
   * Loads index in Web Worker to prevent UI freezing
   */
  const thesaurusWorker = useThesaurusWorker();

  /**
   * Thesaurus index for hierarchical tag display
   * Load the same index for the UI (for grouping tags by hierarchy)
   */
  const [thesaurusIndexForDisplay, setThesaurusIndexForDisplay] = 
    useState<ThesaurusIndexItem[] | null>(null);

  // Load thesaurus index once when worker is ready
  useEffect(() => {
    if (thesaurusWorker.ready && !thesaurusIndexForDisplay) {
      loadThesaurusIndex()
        .then(setThesaurusIndexForDisplay)
        .catch(err => {
          console.error('Failed to load thesaurus for display:', err);
        });
    }
  }, [thesaurusWorker.ready, thesaurusIndexForDisplay]);

  /**
   * ============================================================================
   * BOOKMARKS & NOTIFICATIONS
   * ============================================================================
   */

  /**
   * ============================================================================
   * TRANSLATION TAB SYSTEM
   * ============================================================================
   */

  /**
   * Active tab: "original" or language code (e.g., "ces", "dan")
   * Determines which content is shown in the editor
   */
  const [activeTab, setActiveTab] = useState<string>("original");

  /**
   * Language selection menu for adding translations
   */
  const [translationMenuAnchor, setTranslationMenuAnchor] =
    useState<HTMLElement | null>(null);
  const openTranslationMenu = (e: React.MouseEvent<HTMLElement>) =>
    setTranslationMenuAnchor(e.currentTarget);
  const closeTranslationMenu = () => setTranslationMenuAnchor(null);

  /**
   * Get list of existing translation languages for this workspace
   */
  const translationLanguages = useMemo(
    () => (currentWs?.translations || []).map((t) => t.language),
    [currentWs]
  );

  /**
   * Snackbar notification system (declared early for use in handlers)
   */
  const [notice, setNotice] = useState<string | null>(null);
  const showNotice = useCallback((msg: string) => setNotice(msg), []);

  /**
   * ============================================================================
   * NER SPANS MANAGEMENT (via custom hook)
   * ============================================================================
   * 
   * NER spans come from two sources:
   * - userSpans: Manually created by user in editor
   * - apiSpans: Generated by ML NER API
   * 
   * Managed by useAnnotationManager hook which handles:
   * - Preserving user annotations when re-running NER
   * - Allowing users to hide API spans without deleting them (soft delete)
   * - Automatic hydration when workspace changes
   */
  const annotations = useAnnotationManager({
    initialUserSpans: currentWs?.userSpans as NerSpan[],
    initialApiSpans: currentWs?.apiSpans as NerSpan[],
    initialDeletedKeys: currentWs?.deletedApiKeys ?? [],
    hydrateKey: currentId,
    activeTab,
    workspace: currentWs,
    onNotice: showNotice,
    setWorkspaces,
  });

  /**
   * Handle switching between tabs
   * Save current content AND NER spans before switching
   */
  const handleTabSwitch = useCallback(
    (tabId: string) => {
      if (!currentId || !currentWs) return;

      // Step 1: Save current content AND spans to workspace
      setWorkspaces((prev) => {
        return prev.map((w) => {
          if (w.id !== currentId) return w;

          if (activeTab === "original") {
            // Save original text and spans
            return { 
              ...w, 
              text, 
              userSpans: annotations.userSpans,
              apiSpans: annotations.apiSpans,
              deletedApiKeys: Array.from(annotations.deletedApiKeys),
              updatedAt: Date.now() 
            };
          } else {
            // Save translation text and spans
            return {
              ...w,
              translations: (w.translations || []).map((t) =>
                t.language === activeTab
                  ? { 
                      ...t, 
                      text, 
                      userSpans: annotations.userSpans,
                      apiSpans: annotations.apiSpans,
                      deletedApiKeys: Array.from(annotations.deletedApiKeys),
                      updatedAt: Date.now() 
                    }
                  : t
              ),
              updatedAt: Date.now(),
            };
          }
        });
      });

      // Step 2: Load new content from current workspace state
      // Spans will be automatically loaded by useAnnotationManager hook when activeTab changes
      let newText = "";

      if (tabId === "original") {
        // Load original text
        newText = currentWs.text || "";
      } else {
        // Load translation text
        const translation = currentWs.translations?.find(
          (t) => t.language === tabId
        );
        newText = translation?.text || "";
      }
      
      // Update editor with new content
      setText(newText);

      // Step 3: Update UI state (this triggers hook hydration for spans)
      setActiveTab(tabId);
      setEditorInstanceKey(`${currentId}:${tabId}:${Date.now()}`);
    },
    [activeTab, currentId, currentWs, text, annotations, setWorkspaces]
  );

  /**
   * Add a new translation language
   * Creates translation via API and adds to workspace
   */
  const handleAddTranslation = useCallback(
    async (targetLang: string) => {
      closeTranslationMenu();

      if (!currentId || !currentWs) return;

      // Capture the current workspace ID and original text at this moment
      // This prevents race conditions if user switches workspaces during translation
      const workspaceId = currentId;
      const originalText = currentWs.text || "";
      
      if (!originalText.trim()) {
        showNotice("Add some text before creating translation.");
        return;
      }

      try {
        // Import translation API and language detection
        const { translateText, detectLanguage } = await import("../lib/translation");

        // Auto-detect source language from the captured original text
        showNotice(`Detecting language...`);
        const detectedLang = await detectLanguage(originalText);
        
        showNotice(`Detected ${detectedLang} → Translating to ${targetLang}...`);

        // Call translation API with the captured original text
        const result = await translateText({
          text: originalText,
          sourceLang: detectedLang as any,
          targetLang: targetLang as any,
        });

        // Create new translation object (store detected source language)
        const newTranslation = {
          language: targetLang,
          text: result.translatedText,
          sourceLang: detectedLang,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        // Add to workspace (use captured workspaceId)
        setWorkspaces((prev) =>
          prev.map((w) =>
            w.id === workspaceId
              ? {
                  ...w,
                  translations: [...(w.translations || []), newTranslation],
                  updatedAt: Date.now(),
                }
              : w
          )
        );

        // Only switch tabs and update editor if still on the same workspace
        if (currentId === workspaceId) {
          // Switch to the new translation tab and load its text
          setActiveTab(targetLang);
          
          // Ensure we have valid text (Slate editor breaks with undefined/null)
          const translatedContent = result.translatedText || "";
          setText(translatedContent);
          
          // Force editor remount for clean state
          setEditorInstanceKey(`${workspaceId}:${targetLang}:${Date.now()}`);
        }

        // Show completion message with detected language info
        if (detectedLang && detectedLang !== "en") {
          showNotice(`Detected ${detectedLang} → Translated to ${targetLang}!`);
        } else {
          showNotice(`Translation to ${targetLang} completed!`);
        }
      } catch (error) {
        console.error("Translation failed:", error);
        showNotice("Translation failed. Try again.");
      }
    },
    [currentId, currentWs, setWorkspaces, showNotice]
  );

  /**
   * Update a translation by re-translating from current original text
   * Useful when original text has been edited
   */
  const handleUpdateTranslation = useCallback(
    async (targetLang: string) => {
      if (!currentId || !currentWs) return;

      // Capture state at the moment user clicks update
      // This prevents race conditions if user switches tabs during translation
      const workspaceId = currentId;
      const originalText = currentWs.text || "";
      
      if (!originalText.trim()) {
        showNotice("Add some text before updating translation.");
        return;
      }

      try {
        // Import translation API and language detection
        const { translateText, detectLanguage } = await import("../lib/translation");

        // Auto-detect source language from the captured original text
        showNotice(`Detecting language...`);
        const detectedLang = await detectLanguage(originalText);
        
        showNotice(`Detected ${detectedLang} → Updating ${targetLang}...`);

        // Call translation API with the captured original text
        const result = await translateText({
          text: originalText,
          sourceLang: detectedLang as any,
          targetLang: targetLang as any,
        });

        // Update existing translation in workspace (ALWAYS happens in background)
        // We DON'T update the editor here to avoid race conditions
        // User will see the updated translation when they switch back to that tab
        setWorkspaces((prev) =>
          prev.map((w) =>
            w.id === workspaceId
              ? {
                  ...w,
                  translations: (w.translations || []).map((t) =>
                    t.language === targetLang
                      ? { ...t, text: result.translatedText, updatedAt: Date.now() }
                      : t
                  ),
                  updatedAt: Date.now(),
                }
              : w
          )
        );

        // If user hasn't switched tabs, reload the current tab to show update
        if (currentId === workspaceId && activeTab === targetLang) {
          // User is still on the same tab - trigger a reload
          handleTabSwitch(targetLang);
        }

        showNotice(`Translation "${targetLang}" updated!`);
      } catch (error) {
        console.error("Translation update failed:", error);
        showNotice("Update failed. Try again.");
      }
    },
    [currentId, currentWs, activeTab, setWorkspaces, showNotice, handleTabSwitch]
  );

  /**
   * Delete a translation language
   * If deleting the active tab, switch to "original" first
   */
  const handleDeleteTranslation = useCallback(
    (targetLang: string) => {
      if (!currentId) return;

      // If deleting the currently active tab, switch to original first
      if (activeTab === targetLang) {
        setActiveTab("original");
        // Ensure text is always a string
        setText(currentWs?.text || "");
        setEditorInstanceKey(`${currentId}:original:${Date.now()}`);
      }

      // Remove translation from workspace
      setWorkspaces((prev) =>
        prev.map((w) =>
          w.id === currentId
            ? {
                ...w,
                translations: (w.translations || []).filter(
                  (t) => t.language !== targetLang
                ),
                updatedAt: Date.now(),
              }
            : w
        )
      );

      showNotice(`Translation "${targetLang}" deleted.`);
    },
    [currentId, currentWs, activeTab, setWorkspaces, showNotice]
  );

  /**
   * ============================================================================
   * AUTOSAVE HOOK
   * ============================================================================
   * 
   * Manages automatic and manual workspace saving with debouncing.
   * Handles hydration guard internally.
   */
  const autosave = useAutoSave(
    currentId ?? null,
    {
      text,
      userSpans: annotations.userSpans,
      apiSpans: annotations.apiSpans,
      deletedApiKeys: annotations.deletedApiKeys,
      tags: tags.combinedTags,
    },
    setWorkspaces,
    {
      delay: 350,
      enabled: true,
      activeTab,
    }
  );

  /**
   * ============================================================================
   * HYDRATION: Load workspace data when switching workspaces
   * ============================================================================
   * 
   * Runs when currentId changes (user switches workspace via URL).
   * 
   * Process:
   * 1. Block autosave (set hydratedIdRef to null via setHydrated)
   * 2. Load text, spans, and metadata from workspace
   * 3. Tags auto-hydrate via useSemanticTags hook (hydrateKey dep)
   * 4. Force Slate editor remount with new key
   * 5. Re-enable autosave (set hydratedIdRef to currentId via setHydrated)
   */
  useEffect(() => {
    if (!currentId) return;
    
    // Block autosave while loading
    autosave.setHydrated(null);

    // Reset to original tab when switching workspaces
    setActiveTab("original");

    // Load text content (ensure it's always a string)
    setText(currentWs?.text || "");
    
    // NER annotation spans are hydrated automatically via useAnnotationManager hook (hydrateKey dependency)
    // (Each translation has its own spans stored separately)

    // Tags are hydrated automatically via useSemanticTags hook (hydrateKey dependency)

    // Force Slate editor remount for clean state (prevents stale selections/placeholders)
    Promise.resolve().then(() => {
      autosave.setHydrated(currentId);
      setEditorInstanceKey(`${currentId}:${currentWs?.updatedAt ?? 0}`);
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentId]);

  /**
   * ============================================================================
   * MANUAL SAVE: Triggered by save button or keyboard shortcut
   * ============================================================================
   * 
   * Immediately saves all workspace data (no debounce).
   * Called by EditorArea when user presses Cmd+S/Ctrl+S or clicks save button.
   * 
   * Delegates to autosave hook's saveNow function.
   */
  const handleSave = useCallback(() => {
    autosave.saveNow(showNotice);
  }, [autosave, showNotice]);

  /**
   * ============================================================================
   * ML API OPERATIONS
   * ============================================================================
   */

  /**
   * Run classification API to generate tag suggestions
   * 
   * Flow:
   * 1. Call classification API with current text
   * 2. Hook updates its internal state with results
   * 3. Save new tags to workspace
   * 4. Show success notification
   * 
   * Replaces API tags but preserves user tags.
   */
  const handleRunClassify = useCallback(async () => {
    if (!text.trim()) {
      showNotice("Paste some text before running classify.");
      return;
    }
    
    // Call classification API via hook
    await tags.runClassify(text);
    
    // Save results to workspace
    if (currentId) {
      setWorkspaces((prev) =>
        prev.map((w) =>
          w.id === currentId
            ? {
                ...w,
                tags: tags.combinedTags,
                updatedAt: Date.now(),
              }
            : w
        )
      );
    }
    
    showNotice("Classification completed.");
  }, [text, currentId, tags, setWorkspaces, showNotice]);

  /**
   * Run NER API to automatically detect and annotate entities
   * 
   * Delegates to useAnnotationManager hook's runNer function.
   * Replaces API spans but preserves user spans.
   */
  const handleRunNer = useCallback(async () => {
    await annotations.runNer(text, currentId ?? null);
  }, [text, currentId, annotations]);


  /**
   * ============================================================================
   * AUTO-SAVE: Save tags to workspace whenever they change
   * ============================================================================
   */
  
  // Auto-save tags to workspace whenever tags.combinedTags changes
  useEffect(() => {
    if (currentId && tags.combinedTags.length > 0) {
      setWorkspaces((prev) =>
        prev.map((w) =>
          w.id === currentId
            ? { ...w, tags: tags.combinedTags, updatedAt: Date.now() }
            : w
        )
      );
    }
  }, [tags.combinedTags, currentId, setWorkspaces]);

  /**
   * ============================================================================
   * TAG HANDLERS
   * ============================================================================
   */

  /**
   * Add a user-created tag
   * Delegates to hook - workspace saving is handled by useEffect
   */
  const addCustomTag = useCallback(
    (name: string, keywordId?: number, parentId?: number) => {
      // Add the tag to state
      tags.addCustomTag(name, keywordId, parentId);
      // Note: Workspace saving is handled automatically by useEffect below
    },
    [tags]
  );

  /**
   * Delete a tag (user or API)
   * Delegates to hook - workspace saving is handled by useEffect
   */
  const deleteTag = useCallback(
    (name: string, keywordId?: number, parentId?: number) => {
      tags.deleteTag(name, keywordId, parentId);
      // Note: Workspace saving is handled automatically by useEffect above
    },
    [tags]
  );

  /**
   * ============================================================================
   * THESAURUS: Custom 750k keyword vocabulary search
   * ============================================================================
   * 
   * Searches your custom thesaurus using a Web Worker (background thread).
   * 
   * Strategy:
   * 1. Worker loads pre-processed index on startup
   * 2. Fuzzy search runs in background (doesn't freeze UI)
   * 3. Returns top 20 matches sorted by relevance
   * 
   * Used by TagThesaurusInput component in RightPanel.
   * 
   * Note: First search may take 1-2s while worker loads index.
   * Subsequent searches are instant (~50-100ms).
   */
  const fetchThesaurus = useCallback(
    async (q: string): Promise<ThesaurusItem[]> => {
      if (!q.trim()) return [];
      
      // Wait for worker to be ready (first load takes ~1-2 seconds)
      if (!thesaurusWorker.ready) {
        // Don't warn on every call, worker is still loading
        return [];
      }
      
      try {
        // Search in worker (non-blocking, runs in background thread)
        const results = await thesaurusWorker.search(q, 20);
        
        // Map to UI format
        return results.map(item => ({
          name: item.label,
          path: item.path,                    // Full hierarchical path
          keywordId: item.id,
          parentId: item.parentId,            // Parent ID to disambiguate duplicates
          isPreferred: item.isPreferred,
          depth: item.depth,
        }));
      } catch (error) {
        console.error('Thesaurus search error:', error);
        return [];
      }
    },
    [thesaurusWorker]
  );

  /**
   * ============================================================================
   * DERIVED DATA FOR UI
   * ============================================================================
   */

  /**
   * Convert tags to format for RightPanel
   * Includes keywordId and parentId if tag has them (from API classification or thesaurus)
   */
  const tagRows: TagRow[] = useMemo(
    () => tags.combinedTags.map((t) => ({ 
      name: t.name, 
      source: t.source,
      // If tag has a 'label' field from API, it's the KeywordID
      keywordId: t.label !== undefined ? Number(t.label) : undefined,
      // Include parentId to disambiguate duplicate KeywordIDs
      parentId: t.parentId,
    })),
    [tags.combinedTags]
  );

  /**
   * ============================================================================
   * RENDER
   * ============================================================================
   * 
   * Layout:
   * - Desktop: Two-column (editor left, tags right)
   * - Mobile: Single column stacked
   * 
   * Components:
   * - BookmarkBar: Quick access links (top of left column)
   * - EditorArea: Main text editor with NER annotations
   * - RightPanel: Tag management with thesaurus
   * - Snackbar: Floating notifications
   */
  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: isMobile ? "column" : "row",
        height: "100vh",
        overflow: "hidden",
        position: "relative",
        px: isMobile ? 0 : 4,
        color: COLORS.text,
      }}
    >
      {/* ========================================================================
          LEFT COLUMN: Editor
          ======================================================================== */}
      <Box
        sx={{
          flex: 1,
          boxSizing: "border-box",
          display: "flex",
          flexDirection: "column",
          height: "88.5vh",
          pl: 4,
          minHeight: 0,
        }}
      >
        {/* Translation tabs bar */}
        <BookmarkBar
          translationLanguages={translationLanguages}
          activeTab={activeTab}
          onTabClick={handleTabSwitch}
          onAddClick={openTranslationMenu}
          anchorEl={translationMenuAnchor}
          onClose={closeTranslationMenu}
          onSelectLanguage={handleAddTranslation}
          onDeleteTranslation={handleDeleteTranslation}
          onUpdateTranslation={handleUpdateTranslation}
        />

        {/* Main editor with text input, NER annotations, and action buttons */}
        <EditorArea
          editorInstanceKey={editorInstanceKey}
          text={text}
          setText={setText}
          onUpload={async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            const content = await file.text();
            setText(content);
          }}
          onClassify={handleRunClassify}
          onNer={handleRunNer}
          spans={annotations.combinedSpans}
          highlightedCategories={[]}
          deletableKeys={annotations.deletableKeys}
          onDeleteSpan={annotations.deleteSpan}
          onAddSpan={annotations.addSpan}
          onSave={handleSave}
        />
      </Box>

      {/* ========================================================================
          RIGHT COLUMN: Tag Management
          ======================================================================== */}
      <Box
        sx={{
          width: isMobile ? "100%" : "300px",
          boxSizing: "border-box",
          height: isMobile ? "60vh" : "86vh",
          display: "flex",
          flexDirection: "column",
          mt: isMobile ? 2 : 4,
          p: isMobile ? 2 : 0,
          pr: { xs: 0, sm: 1 },
          minHeight: 0,
          overflow: "visible",
          ml: { xs: 0, sm: 2 },
        }}
      >
        {!isMobile ? (
          // Desktop: Clean tag panel with hierarchical display
          <RightPanel
            tags={tagRows}
            onDeleteTag={deleteTag}
            thesaurus={{
              onAdd: (name, keywordId, parentId) => addCustomTag(name, keywordId, parentId),
              fetchSuggestions: fetchThesaurus,
              defaultRestrictToThesaurus: false,
              isThesaurusLoading: !thesaurusWorker.ready,
              resetKey: currentId,  // Force input reset when workspace changes
            }}
            thesaurusIndex={thesaurusIndexForDisplay || undefined}
          />
        ) : (
          // Mobile: Tag panel with title
          <>
            <Typography
              variant="h6"
              sx={{
                mb: 1,
                color: COLORS.gold,
                fontWeight: 900,
                textTransform: "uppercase",
                letterSpacing: 0.5,
                textShadow: "0 1px 2px rgba(0,0,0,0.35)",
              }}
            >
              Tags
            </Typography>
            <Box sx={{ flex: 1, minHeight: 0 }}>
              <RightPanel
                tags={tagRows}
                onDeleteTag={deleteTag}
                thesaurus={{
                  onAdd: (name, keywordId, parentId) => addCustomTag(name, keywordId, parentId),
                  fetchSuggestions: fetchThesaurus,
                  defaultRestrictToThesaurus: false,
                  isThesaurusLoading: !thesaurusWorker.ready,
                  resetKey: currentId,  // Force input reset when workspace changes
                }}
                thesaurusIndex={thesaurusIndexForDisplay || undefined}
              />
            </Box>
          </>
        )}
      </Box>

      {/* ========================================================================
          NOTIFICATIONS
          ======================================================================== */}
      <Snackbar
        open={!!notice}
        autoHideDuration={2200}
        onClose={() => setNotice(null)}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={() => setNotice(null)}
          severity="info"
          variant="filled"
          sx={{ bgcolor: "#21426C" }}
        >
          {notice}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default WorkspacePage;
