// src/pages/WorkspacePage.tsx
/**
 * WorkspacePage - Main page for editing and annotating text documents
 * 
 * This is the primary workspace interface where users:
 * - Edit text content in a rich editor
 * - Annotate text with NER (Named Entity Recognition) spans
 * - Add semantic tags/keywords to documents
 * - Run ML classification and NER APIs
 * - Switch between multiple workspaces
 * 
 * ARCHITECTURE:
 * 
 * 1. Multi-Workspace Support:
 *    - Users can have multiple workspaces
 *    - Route parameter determines active workspace (URL: /workspace/:id)
 *    - Switching workspaces triggers hydration (loading saved data)
 * 
 * 2. Data Persistence:
 *    - Autosave: Changes saved automatically after 350ms delay
 *    - Manual Save: Cmd+S / Ctrl+S trigger immediate save
 *    - Workspaces stored in parent App component state
 * 
 * 3. NER Annotations (Two Sources):
 *    - User spans: Manually annotated by user in editor
 *    - API spans: Generated by ML NER model
 *    - Users can hide API spans without deleting (deletedApiKeys)
 * 
 * 4. Tags (Two Sources):
 *    - User tags: Manually entered keywords
 *    - API tags: Generated by classification ML model
 *    - Managed by useSemanticTags hook
 * 
 * 5. Layout:
 *    - Left: BookmarkBar + EditorArea (NotationEditor)
 *    - Right: RightPanel (tag management)
 *    - Bottom: Snackbar notifications
 */
import React, {
  useMemo,
  useState,
  useCallback,
  useEffect,
  useRef,
} from "react";
import {
  Box,
  Typography,
  useMediaQuery,
  useTheme,
  Snackbar,
  Alert,
} from "@mui/material";
import { useParams } from "react-router-dom";

import type { Workspace } from "../types/Workspace";
import type { NerSpan } from "../types/NotationEditor";

import BookmarkBar from "../components/workspace/BookmarkBar";
import EditorArea from "../components/workspace/EditorArea";
import RightPanel, { type TagRow } from "../components/right/RightPanel";
import type { ThesaurusItem } from "../components/tags/TagThesaurusInput";

import { useSemanticTags } from "../hooks/useSemanticTags";
import { useThesaurusWorker } from "../hooks/useThesaurusWorker";
import { loadThesaurusIndex } from "../lib/thesaurusHelpers";
import type { ThesaurusIndexItem } from "../types/Thesaurus";

/**
 * Create a unique key for an NER span (for comparison/deduplication)
 */
const keyOfSpan = (s: NerSpan) => `${s.start}:${s.end}:${s.entity}`;

interface Props {
  workspaces: Workspace[];
  setWorkspaces: React.Dispatch<React.SetStateAction<Workspace[]>>;
}

const COLORS = {
  text: "#0F172A",
  gold: "#DDD1A0",
};

const WorkspacePage: React.FC<Props> = ({ workspaces, setWorkspaces }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
  const { id: routeId } = useParams();

  /**
   * ============================================================================
   * WORKSPACE SELECTION
   * ============================================================================
   */

  /**
   * Find the current workspace from URL parameter
   * Falls back to first workspace if ID not found
   */
  const currentWs = useMemo(
    () => workspaces.find((w) => w.id === routeId) ?? workspaces[0],
    [workspaces, routeId]
  );
  const currentId = currentWs?.id;

  /**
   * ============================================================================
   * EDITOR STATE
   * ============================================================================
   */

  /**
   * Key to force Slate editor remount on workspace change
   * Ensures clean selection & placeholder state
   */
  const [editorInstanceKey, setEditorInstanceKey] = useState<string>("");
  
  /**
   * Main text content being edited
   */
  const [text, setText] = useState<string>("");

  /**
   * ============================================================================
   * TAGS & NER MANAGEMENT (via custom hooks)
   * ============================================================================
   */

  /**
   * Semantic tags hook - manages user and API-generated tags
   * Automatically hydrates when currentId changes (hydrateKey)
   */
  const tags = useSemanticTags({
    initialTags: currentWs?.tags,
    hydrateKey: currentId,
  });

  /**
   * NER annotations hook - provides API functions for NER
   * Note: We manage spans locally for workspace persistence
   */
  // const ner = useNerAnnotations(); // Unused - kept for potential future use

  /**
   * Thesaurus worker - background search for 750k keywords
   * Loads index in Web Worker to prevent UI freezing
   */
  const thesaurusWorker = useThesaurusWorker();

  /**
   * Thesaurus index for hierarchical tag display
   * Load the same index for the UI (for grouping tags by hierarchy)
   */
  const [thesaurusIndexForDisplay, setThesaurusIndexForDisplay] = 
    useState<ThesaurusIndexItem[] | null>(null);

  // Load thesaurus index once when worker is ready
  useEffect(() => {
    if (thesaurusWorker.ready && !thesaurusIndexForDisplay) {
      loadThesaurusIndex()
        .then(setThesaurusIndexForDisplay)
        .catch(err => {
          console.error('Failed to load thesaurus for display:', err);
        });
    }
  }, [thesaurusWorker.ready, thesaurusIndexForDisplay]);

  /**
   * ============================================================================
   * NER SPANS STATE
   * ============================================================================
   * 
   * NER spans come from two sources:
   * - userSpans: Manually created by user in editor
   * - apiSpans: Generated by ML NER API
   * 
   * We track them separately for:
   * - Preserving user annotations when re-running NER
   * - Allowing users to hide API spans without deleting them
   */
  const [userSpans, setUserSpans] = useState<NerSpan[]>([]);
  const [apiSpans, setApiSpans] = useState<NerSpan[]>([]);
  
  /**
   * Set of span keys that user has "deleted" (hidden from view)
   * Allows soft-delete of API spans without removing from workspace
   */
  const [deletedApiKeys, setDeletedApiKeys] = useState<Set<string>>(new Set());

  /**
   * ============================================================================
   * BOOKMARKS & NOTIFICATIONS
   * ============================================================================
   */

  /**
   * ============================================================================
   * TRANSLATION TAB SYSTEM
   * ============================================================================
   */

  /**
   * Active tab: "original" or language code (e.g., "ces", "dan")
   * Determines which content is shown in the editor
   */
  const [activeTab, setActiveTab] = useState<string>("original");

  /**
   * Language selection menu for adding translations
   */
  const [translationMenuAnchor, setTranslationMenuAnchor] =
    useState<HTMLElement | null>(null);
  const openTranslationMenu = (e: React.MouseEvent<HTMLElement>) =>
    setTranslationMenuAnchor(e.currentTarget);
  const closeTranslationMenu = () => setTranslationMenuAnchor(null);

  /**
   * Get list of existing translation languages for this workspace
   */
  const translationLanguages = useMemo(
    () => (currentWs?.translations || []).map((t) => t.language),
    [currentWs]
  );

  /**
   * Snackbar notification system (declared early for use in handlers)
   */
  const [notice, setNotice] = useState<string | null>(null);
  const showNotice = useCallback((msg: string) => setNotice(msg), []);

  /**
   * Handle switching between tabs
   * Save current content AND NER spans before switching
   */
  const handleTabSwitch = useCallback(
    (tabId: string) => {
      if (!currentId || !currentWs) return;

      // Step 1: Save current content AND spans to workspace
      setWorkspaces((prev) => {
        return prev.map((w) => {
          if (w.id !== currentId) return w;

          if (activeTab === "original") {
            // Save original text and spans
            return { 
              ...w, 
              text, 
              userSpans,
              apiSpans,
              deletedApiKeys: Array.from(deletedApiKeys),
              updatedAt: Date.now() 
            };
          } else {
            // Save translation text and spans
            return {
              ...w,
              translations: (w.translations || []).map((t) =>
                t.language === activeTab
                  ? { 
                      ...t, 
                      text, 
                      userSpans,
                      apiSpans,
                      deletedApiKeys: Array.from(deletedApiKeys),
                      updatedAt: Date.now() 
                    }
                  : t
              ),
              updatedAt: Date.now(),
            };
          }
        });
      });

      // Step 2: Load new content AND spans from current workspace state
      let newText = "";
      let newUserSpans: NerSpan[] = [];
      let newApiSpans: NerSpan[] = [];
      let newDeletedKeys: string[] = [];

      if (tabId === "original") {
        // Load original text and spans
        newText = currentWs.text || "";
        newUserSpans = (currentWs.userSpans as NerSpan[]) ?? [];
        newApiSpans = (currentWs.apiSpans as NerSpan[]) ?? [];
        newDeletedKeys = currentWs.deletedApiKeys ?? [];
      } else {
        // Load translation text and spans
        const translation = currentWs.translations?.find(
          (t) => t.language === tabId
        );
        newText = translation?.text || "";
        newUserSpans = (translation?.userSpans as NerSpan[]) ?? [];
        newApiSpans = (translation?.apiSpans as NerSpan[]) ?? [];
        newDeletedKeys = translation?.deletedApiKeys ?? [];
      }
      
      // Update editor with new content and spans
      setText(newText);
      setUserSpans(newUserSpans);
      setApiSpans(newApiSpans);
      setDeletedApiKeys(new Set(newDeletedKeys));

      // Step 3: Update UI state
      setActiveTab(tabId);
      setEditorInstanceKey(`${currentId}:${tabId}:${Date.now()}`);
    },
    [activeTab, currentId, currentWs, text, userSpans, apiSpans, deletedApiKeys, setWorkspaces]
  );

  /**
   * Add a new translation language
   * Creates translation via API and adds to workspace
   */
  const handleAddTranslation = useCallback(
    async (targetLang: string) => {
      closeTranslationMenu();

      if (!currentId || !currentWs) return;

      // Capture the current workspace ID and original text at this moment
      // This prevents race conditions if user switches workspaces during translation
      const workspaceId = currentId;
      const originalText = currentWs.text || "";
      
      if (!originalText.trim()) {
        showNotice("Add some text before creating translation.");
        return;
      }

      try {
        // Import translation API and language detection
        const { translateText, detectLanguage } = await import("../lib/translation");

        // Auto-detect source language from the captured original text
        showNotice(`Detecting language...`);
        const detectedLang = await detectLanguage(originalText);
        
        showNotice(`Detected ${detectedLang} → Translating to ${targetLang}...`);

        // Call translation API with the captured original text
        const result = await translateText({
          text: originalText,
          sourceLang: detectedLang as any,
          targetLang: targetLang as any,
        });

        // Create new translation object (store detected source language)
        const newTranslation = {
          language: targetLang,
          text: result.translatedText,
          sourceLang: detectedLang,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        // Add to workspace (use captured workspaceId)
        setWorkspaces((prev) =>
          prev.map((w) =>
            w.id === workspaceId
              ? {
                  ...w,
                  translations: [...(w.translations || []), newTranslation],
                  updatedAt: Date.now(),
                }
              : w
          )
        );

        // Only switch tabs and update editor if still on the same workspace
        if (currentId === workspaceId) {
          // Switch to the new translation tab and load its text
          setActiveTab(targetLang);
          
          // Ensure we have valid text (Slate editor breaks with undefined/null)
          const translatedContent = result.translatedText || "";
          setText(translatedContent);
          
          // Force editor remount for clean state
          setEditorInstanceKey(`${workspaceId}:${targetLang}:${Date.now()}`);
        }

        // Show completion message with detected language info
        if (detectedLang && detectedLang !== "en") {
          showNotice(`Detected ${detectedLang} → Translated to ${targetLang}!`);
        } else {
          showNotice(`Translation to ${targetLang} completed!`);
        }
      } catch (error) {
        console.error("Translation failed:", error);
        showNotice("Translation failed. Try again.");
      }
    },
    [currentId, currentWs, setWorkspaces, showNotice]
  );

  /**
   * Update a translation by re-translating from current original text
   * Useful when original text has been edited
   */
  const handleUpdateTranslation = useCallback(
    async (targetLang: string) => {
      if (!currentId || !currentWs) return;

      // Capture state at the moment user clicks update
      // This prevents race conditions if user switches tabs during translation
      const workspaceId = currentId;
      const originalText = currentWs.text || "";
      
      if (!originalText.trim()) {
        showNotice("Add some text before updating translation.");
        return;
      }

      try {
        // Import translation API and language detection
        const { translateText, detectLanguage } = await import("../lib/translation");

        // Auto-detect source language from the captured original text
        showNotice(`Detecting language...`);
        const detectedLang = await detectLanguage(originalText);
        
        showNotice(`Detected ${detectedLang} → Updating ${targetLang}...`);

        // Call translation API with the captured original text
        const result = await translateText({
          text: originalText,
          sourceLang: detectedLang as any,
          targetLang: targetLang as any,
        });

        // Update existing translation in workspace (ALWAYS happens in background)
        // We DON'T update the editor here to avoid race conditions
        // User will see the updated translation when they switch back to that tab
        setWorkspaces((prev) =>
          prev.map((w) =>
            w.id === workspaceId
              ? {
                  ...w,
                  translations: (w.translations || []).map((t) =>
                    t.language === targetLang
                      ? { ...t, text: result.translatedText, updatedAt: Date.now() }
                      : t
                  ),
                  updatedAt: Date.now(),
                }
              : w
          )
        );

        // If user hasn't switched tabs, reload the current tab to show update
        if (currentId === workspaceId && activeTab === targetLang) {
          // User is still on the same tab - trigger a reload
          handleTabSwitch(targetLang);
        }

        showNotice(`Translation "${targetLang}" updated!`);
      } catch (error) {
        console.error("Translation update failed:", error);
        showNotice("Update failed. Try again.");
      }
    },
    [currentId, currentWs, activeTab, setWorkspaces, showNotice, handleTabSwitch]
  );

  /**
   * Delete a translation language
   * If deleting the active tab, switch to "original" first
   */
  const handleDeleteTranslation = useCallback(
    (targetLang: string) => {
      if (!currentId) return;

      // If deleting the currently active tab, switch to original first
      if (activeTab === targetLang) {
        setActiveTab("original");
        // Ensure text is always a string
        setText(currentWs?.text || "");
        setEditorInstanceKey(`${currentId}:original:${Date.now()}`);
      }

      // Remove translation from workspace
      setWorkspaces((prev) =>
        prev.map((w) =>
          w.id === currentId
            ? {
                ...w,
                translations: (w.translations || []).filter(
                  (t) => t.language !== targetLang
                ),
                updatedAt: Date.now(),
              }
            : w
        )
      );

      showNotice(`Translation "${targetLang}" deleted.`);
    },
    [currentId, currentWs, activeTab, setWorkspaces, showNotice]
  );

  /**
   * ============================================================================
   * HYDRATION GUARD
   * ============================================================================
   * 
   * Prevents autosave from firing while loading workspace data.
   * Set to null during hydration, then set to workspace ID when complete.
   */
  const hydratedIdRef = useRef<string | null>(null);

  /**
   * ============================================================================
   * HYDRATION: Load workspace data when switching workspaces
   * ============================================================================
   * 
   * Runs when currentId changes (user switches workspace via URL).
   * 
   * Process:
   * 1. Block autosave (set hydratedIdRef to null)
   * 2. Load text, spans, and metadata from workspace
   * 3. Tags auto-hydrate via useSemanticTags hook (hydrateKey dep)
   * 4. Force Slate editor remount with new key
   * 5. Re-enable autosave (set hydratedIdRef to currentId)
   */
  useEffect(() => {
    if (!currentId) return;
    
    // Block autosave while loading
    hydratedIdRef.current = null;

    // Reset to original tab when switching workspaces
    setActiveTab("original");

    // Load text content (ensure it's always a string)
    setText(currentWs?.text || "");
    
    // Load NER annotation spans for Original tab
    // (Each translation has its own spans stored separately)
    setUserSpans((currentWs?.userSpans as NerSpan[]) ?? []);
    setApiSpans((currentWs?.apiSpans as NerSpan[]) ?? []);
    setDeletedApiKeys(new Set(currentWs?.deletedApiKeys ?? []));

    // Tags are hydrated automatically via useSemanticTags hook (hydrateKey dependency)

    // Force Slate editor remount for clean state (prevents stale selections/placeholders)
    Promise.resolve().then(() => {
      hydratedIdRef.current = currentId;
      setEditorInstanceKey(`${currentId}:${currentWs?.updatedAt ?? 0}`);
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentId]);

  /**
   * ============================================================================
   * AUTOSAVE: Debounced automatic saving
   * ============================================================================
   * 
   * Automatically saves workspace changes 350ms after user stops editing.
   * 
   * Guards:
   * - Only saves after hydration complete (hydratedIdRef check)
   * - Cancels previous timer if user is still editing
   * 
   * What gets saved:
   * - Text content (original or translation based on activeTab)
   * - User and API NER spans
   * - Deleted span keys (soft deletes)
   * - Combined tags from hook
   * - Updated timestamp
   */
  const saveTimer = useRef<number | null>(null);
  useEffect(() => {
    // Don't save if no workspace selected
    if (!currentId) return;
    
    // Don't save if still loading workspace (hydration in progress)
    if (hydratedIdRef.current !== currentId) return;

    // Cancel previous save timer
    if (saveTimer.current) window.clearTimeout(saveTimer.current);
    
    // Schedule save for 350ms from now
    saveTimer.current = window.setTimeout(() => {
      setWorkspaces((prev) =>
        prev.map((w) => {
          if (w.id !== currentId) return w;

          // If on original tab, save text and spans to workspace root
          if (activeTab === "original") {
            return {
              ...w,
              text,
              userSpans,
              apiSpans,
              deletedApiKeys: Array.from(deletedApiKeys),
              tags: tags.combinedTags,
              updatedAt: Date.now(),
            };
          }

          // If on translation tab, save text and spans to that translation
          return {
            ...w,
            translations: (w.translations || []).map((t) =>
              t.language === activeTab
                ? { 
                    ...t, 
                    text, 
                    userSpans,
                    apiSpans,
                    deletedApiKeys: Array.from(deletedApiKeys),
                    updatedAt: Date.now() 
                  }
                : t
            ),
            tags: tags.combinedTags,
            updatedAt: Date.now(),
          };
        })
      );
    }, 350);

    // Cleanup: cancel timer if component unmounts or dependencies change
    return () => {
      if (saveTimer.current) window.clearTimeout(saveTimer.current);
    };
  }, [
    currentId,
    activeTab,
    text,
    userSpans,
    apiSpans,
    deletedApiKeys,
    tags.combinedTags,
    setWorkspaces,
  ]);

  /**
   * ============================================================================
   * MANUAL SAVE: Triggered by save button or keyboard shortcut
   * ============================================================================
   * 
   * Immediately saves all workspace data (no debounce).
   * Called by EditorArea when user presses Cmd+S/Ctrl+S or clicks save button.
   * 
   * Ensures hydratedIdRef is set (enables autosave after manual save).
   */
  const handleSave = useCallback(() => {
    if (!currentId) return;
    
    // Mark as hydrated (enables autosave)
    hydratedIdRef.current = currentId;
    
    // Save workspace data
    setWorkspaces((prev) =>
      prev.map((w) => {
        if (w.id !== currentId) return w;

        // If on original tab, save text and spans to workspace root
        if (activeTab === "original") {
          return {
            ...w,
            text,
            userSpans,
            apiSpans,
            deletedApiKeys: Array.from(deletedApiKeys),
            tags: tags.combinedTags,
            updatedAt: Date.now(),
          };
        }

        // If on translation tab, save text and spans to that translation
        return {
          ...w,
          translations: (w.translations || []).map((t) =>
            t.language === activeTab
              ? { 
                  ...t, 
                  text, 
                  userSpans,
                  apiSpans,
                  deletedApiKeys: Array.from(deletedApiKeys),
                  updatedAt: Date.now() 
                }
              : t
          ),
          tags: tags.combinedTags,
          updatedAt: Date.now(),
        };
      })
    );
    
    // Show confirmation
    setNotice("Workspace saved.");
  }, [
    currentId,
    activeTab,
    text,
    userSpans,
    apiSpans,
    deletedApiKeys,
    tags.combinedTags,
    setWorkspaces,
  ]);

  /**
   * ============================================================================
   * ML API OPERATIONS
   * ============================================================================
   */

  /**
   * Run classification API to generate tag suggestions
   * 
   * Flow:
   * 1. Call classification API with current text
   * 2. Hook updates its internal state with results
   * 3. Save new tags to workspace
   * 4. Show success notification
   * 
   * Replaces API tags but preserves user tags.
   */
  const handleRunClassify = useCallback(async () => {
    if (!text.trim()) {
      showNotice("Paste some text before running classify.");
      return;
    }
    
    // Call classification API via hook
    await tags.runClassify(text);
    
    // Save results to workspace
    if (currentId) {
      setWorkspaces((prev) =>
        prev.map((w) =>
          w.id === currentId
            ? {
                ...w,
                tags: tags.combinedTags,
                updatedAt: Date.now(),
              }
            : w
        )
      );
    }
    
    showNotice("Classification completed.");
  }, [text, currentId, tags, setWorkspaces, showNotice]);

  /**
   * Run NER API to automatically detect and annotate entities
   * 
   * Flow:
   * 1. Call NER API with current text
   * 2. Hook updates its internal state with results
   * 3. Copy results to local apiSpans state
   * 4. Save to workspace
   * 5. Show success notification
   * 
   * Replaces API spans but preserves user spans.
   */
  const handleRunNer = useCallback(async () => {
    if (!text.trim()) {
      showNotice("Paste some text before running NER.");
      return;
    }
    
    try {
      // Call NER API directly instead of using hook to avoid timing issues
      const { ner: apiNer } = await import("../lib/api");
      const data = await apiNer(text);
      
      // Transform API response into NerSpan array
      const spans = (data.result ?? []).map((r: any) => ({
        start: r.start,
        end: r.end,
        entity: r.type, // API returns 'type' field, map to 'entity'
        score: 1.0, // API doesn't provide score, use default
      }));
      setApiSpans(spans);
      
      // Clear deletedApiKeys when running new NER to show all new results
      setDeletedApiKeys(new Set());
      
      // Save to workspace
      if (currentId) {
        setWorkspaces((prev) =>
          prev.map((w) =>
            w.id === currentId
              ? { ...w, apiSpans: spans, deletedApiKeys: [], updatedAt: Date.now() }
              : w
          )
        );
      }
      
      showNotice("NER completed.");
    } catch (error) {
      console.error('NER failed:', error);
      showNotice("NER failed. Try again.");
    }
  }, [text, currentId, setWorkspaces, showNotice]);


  /**
   * ============================================================================
   * AUTO-SAVE: Save tags to workspace whenever they change
   * ============================================================================
   */
  
  // Auto-save tags to workspace whenever tags.combinedTags changes
  useEffect(() => {
    if (currentId && tags.combinedTags.length > 0) {
      setWorkspaces((prev) =>
        prev.map((w) =>
          w.id === currentId
            ? { ...w, tags: tags.combinedTags, updatedAt: Date.now() }
            : w
        )
      );
    }
  }, [tags.combinedTags, currentId, setWorkspaces]);

  /**
   * ============================================================================
   * TAG HANDLERS
   * ============================================================================
   */

  /**
   * Add a user-created tag
   * Delegates to hook - workspace saving is handled by useEffect
   */
  const addCustomTag = useCallback(
    (name: string, keywordId?: number, parentId?: number) => {
      // Add the tag to state
      tags.addCustomTag(name, keywordId, parentId);
      // Note: Workspace saving is handled automatically by useEffect below
    },
    [tags]
  );

  /**
   * Delete a tag (user or API)
   * Delegates to hook - workspace saving is handled by useEffect
   */
  const deleteTag = useCallback(
    (name: string, keywordId?: number, parentId?: number) => {
      tags.deleteTag(name, keywordId, parentId);
      // Note: Workspace saving is handled automatically by useEffect above
    },
    [tags]
  );

  /**
   * ============================================================================
   * THESAURUS: Custom 750k keyword vocabulary search
   * ============================================================================
   * 
   * Searches your custom thesaurus using a Web Worker (background thread).
   * 
   * Strategy:
   * 1. Worker loads pre-processed index on startup
   * 2. Fuzzy search runs in background (doesn't freeze UI)
   * 3. Returns top 20 matches sorted by relevance
   * 
   * Used by TagThesaurusInput component in RightPanel.
   * 
   * Note: First search may take 1-2s while worker loads index.
   * Subsequent searches are instant (~50-100ms).
   */
  const fetchThesaurus = useCallback(
    async (q: string): Promise<ThesaurusItem[]> => {
      if (!q.trim()) return [];
      
      // Wait for worker to be ready (first load takes ~1-2 seconds)
      if (!thesaurusWorker.ready) {
        // Don't warn on every call, worker is still loading
        return [];
      }
      
      try {
        // Search in worker (non-blocking, runs in background thread)
        const results = await thesaurusWorker.search(q, 20);
        
        // Map to UI format
        return results.map(item => ({
          name: item.label,
          path: item.path,                    // Full hierarchical path
          keywordId: item.id,
          parentId: item.parentId,            // Parent ID to disambiguate duplicates
          isPreferred: item.isPreferred,
          depth: item.depth,
        }));
      } catch (error) {
        console.error('Thesaurus search error:', error);
        return [];
      }
    },
    [thesaurusWorker]
  );

  /**
   * ============================================================================
   * DERIVED DATA FOR UI
   * ============================================================================
   */

  /**
   * Convert tags to format expected by RightPanel
   */
  /**
   * Convert tags to format for RightPanel
   * Includes keywordId and parentId if tag has them (from API classification or thesaurus)
   */
  const tagRows: TagRow[] = useMemo(
    () => tags.combinedTags.map((t) => ({ 
      name: t.name, 
      source: t.source,
      // If tag has a 'label' field from API, it's the KeywordID
      keywordId: t.label !== undefined ? Number(t.label) : undefined,
      // Include parentId to disambiguate duplicate KeywordIDs
      parentId: t.parentId,
    })),
    [tags.combinedTags]
  );

  /**
   * Filter out API spans that user has soft-deleted
   * (deletedApiKeys contains keys of hidden spans)
   */
  const filteredApiSpans = useMemo(
    () => apiSpans.filter((s) => !deletedApiKeys.has(keyOfSpan(s))),
    [apiSpans, deletedApiKeys]
  );

  /**
   * Combine visible API spans with user spans for editor display
   */
  const combinedSpans = useMemo<NerSpan[]>(
    () => [...filteredApiSpans, ...userSpans],
    [filteredApiSpans, userSpans]
  );

  /**
   * Set of all span keys that can be deleted
   * Used by editor to show delete options
   */
  const deletableKeys = useMemo(() => {
    const keys = new Set<string>();
    filteredApiSpans.forEach((s) => keys.add(keyOfSpan(s)));
    userSpans.forEach((s) => keys.add(keyOfSpan(s)));
    return keys;
  }, [filteredApiSpans, userSpans]);

  /**
   * ============================================================================
   * NER SPAN HANDLERS
   * ============================================================================
   */

  /**
   * Delete a span (called from editor)
   * 
   * Strategy:
   * - If it's a user span: Remove from userSpans
   * - If it's an API span: Add to deletedApiKeys (soft delete)
   * 
   * Soft-delete for API spans allows them to reappear if user re-runs NER.
   */
  const handleDeleteSpan = useCallback(
    (span: NerSpan) => {
      const k = keyOfSpan(span);
      
      if (userSpans.some((s) => keyOfSpan(s) === k)) {
        // Hard delete user spans
        setUserSpans((prev) => prev.filter((s) => keyOfSpan(s) !== k));
      } else {
        // Soft delete API spans
        setDeletedApiKeys((prev) => new Set(prev).add(k));
      }
    },
    [userSpans]
  );

  /**
   * Add or update a span (called from editor when user annotates text)
   * 
   * Flow:
   * 1. Remove from deletedApiKeys (in case it was soft-deleted)
   * 2. Add to userSpans (prevent duplicates)
   * 
   * Called when user manually annotates text or changes entity type.
   */
  const handleAddSpan = useCallback(
    (span: NerSpan) => {
      const k = keyOfSpan(span);
      
      // Un-delete if it was soft-deleted
      setDeletedApiKeys((prev) => {
        const next = new Set(prev);
        next.delete(k);
        return next;
      });
      
      // Add to user spans (avoid duplicates)
      setUserSpans((prev) => {
        if (prev.some((s) => keyOfSpan(s) === k)) return prev;
        return [...prev, span];
      });
    },
    [setUserSpans, setDeletedApiKeys]
  );

  /**
   * ============================================================================
   * RENDER
   * ============================================================================
   * 
   * Layout:
   * - Desktop: Two-column (editor left, tags right)
   * - Mobile: Single column stacked
   * 
   * Components:
   * - BookmarkBar: Quick access links (top of left column)
   * - EditorArea: Main text editor with NER annotations
   * - RightPanel: Tag management with thesaurus
   * - Snackbar: Floating notifications
   */
  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: isMobile ? "column" : "row",
        height: "100vh",
        overflow: "hidden",
        position: "relative",
        px: isMobile ? 0 : 4,
        color: COLORS.text,
      }}
    >
      {/* ========================================================================
          LEFT COLUMN: Editor
          ======================================================================== */}
      <Box
        sx={{
          flex: 1,
          boxSizing: "border-box",
          display: "flex",
          flexDirection: "column",
          height: "88.5vh",
          pl: 4,
          minHeight: 0,
        }}
      >
        {/* Translation tabs bar */}
        <BookmarkBar
          translationLanguages={translationLanguages}
          activeTab={activeTab}
          onTabClick={handleTabSwitch}
          onAddClick={openTranslationMenu}
          anchorEl={translationMenuAnchor}
          onClose={closeTranslationMenu}
          onSelectLanguage={handleAddTranslation}
          onDeleteTranslation={handleDeleteTranslation}
          onUpdateTranslation={handleUpdateTranslation}
        />

        {/* Main editor with text input, NER annotations, and action buttons */}
        <EditorArea
          editorInstanceKey={editorInstanceKey}
          text={text}
          setText={setText}
          onUpload={async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            const content = await file.text();
            setText(content);
          }}
          onClassify={handleRunClassify}
          onNer={handleRunNer}
          spans={combinedSpans}
          highlightedCategories={[]}
          deletableKeys={deletableKeys}
          onDeleteSpan={handleDeleteSpan}
          onAddSpan={handleAddSpan}
          onSave={handleSave}
        />
      </Box>

      {/* ========================================================================
          RIGHT COLUMN: Tag Management
          ======================================================================== */}
      <Box
        sx={{
          width: isMobile ? "100%" : "300px",
          boxSizing: "border-box",
          height: isMobile ? "60vh" : "86vh",
          display: "flex",
          flexDirection: "column",
          mt: isMobile ? 2 : 4,
          p: isMobile ? 2 : 0,
          pr: { xs: 0, sm: 1 },
          minHeight: 0,
          overflow: "visible",
          ml: { xs: 0, sm: 2 },
        }}
      >
        {!isMobile ? (
          // Desktop: Clean tag panel with hierarchical display
          <RightPanel
            tags={tagRows}
            onDeleteTag={deleteTag}
            thesaurus={{
              onAdd: (name, keywordId, parentId) => addCustomTag(name, keywordId, parentId),
              fetchSuggestions: fetchThesaurus,
              defaultRestrictToThesaurus: false,
              isThesaurusLoading: !thesaurusWorker.ready,
              resetKey: currentId,  // Force input reset when workspace changes
            }}
            thesaurusIndex={thesaurusIndexForDisplay || undefined}
          />
        ) : (
          // Mobile: Tag panel with title
          <>
            <Typography
              variant="h6"
              sx={{
                mb: 1,
                color: COLORS.gold,
                fontWeight: 900,
                textTransform: "uppercase",
                letterSpacing: 0.5,
                textShadow: "0 1px 2px rgba(0,0,0,0.35)",
              }}
            >
              Tags
            </Typography>
            <Box sx={{ flex: 1, minHeight: 0 }}>
              <RightPanel
                tags={tagRows}
                onDeleteTag={deleteTag}
                thesaurus={{
                  onAdd: (name, keywordId, parentId) => addCustomTag(name, keywordId, parentId),
                  fetchSuggestions: fetchThesaurus,
                  defaultRestrictToThesaurus: false,
                  isThesaurusLoading: !thesaurusWorker.ready,
                  resetKey: currentId,  // Force input reset when workspace changes
                }}
                thesaurusIndex={thesaurusIndexForDisplay || undefined}
              />
            </Box>
          </>
        )}
      </Box>

      {/* ========================================================================
          NOTIFICATIONS
          ======================================================================== */}
      <Snackbar
        open={!!notice}
        autoHideDuration={2200}
        onClose={() => setNotice(null)}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={() => setNotice(null)}
          severity="info"
          variant="filled"
          sx={{ bgcolor: "#21426C" }}
        >
          {notice}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default WorkspacePage;
